var spawn = require("child_process").spawn;

//	{
//		// The command to execute. It should be in the system path.
//		cmd: commandToExecute,
//		// An array of arguments to pass to the command.
//		args: arrayOfArguments,
//		// Additional options for the Node.js child_process spawn method.
//		opts: nodeSpawnOptions
//	}

module.exports = function (grunt) {
	grunt.utils.exec = function (options, callback) {
		var build = grunt.utils.spawn(options, callback);

		build.stdout.on("data", function (buf) {
			grunt.log.write("" + buf);
		});

		build.stderr.on("data", function (buf) {
			grunt.log.write("" + buf);
		});

		build.on("exit", function (code) {
			callback(null, code);
		});

		return build;
	};

	// Generated by CoffeeScript 1.3.1
	(function () {
		var crypto, https, joinBuffers, postToS3, readText, signPolicy, url, _ref;

		url = require('url');

		https = require('https');

		crypto = require('crypto');

		_ref = require('tafa-misc-util'), joinBuffers = _ref.joinBuffers, readText = _ref.readText;

		signPolicy = function (secretKey, policy) {
			var data, hmac, json, key, policy64, signature64;
			json = JSON.stringify(policy);
			policy64 = new Buffer(json).toString('base64');
			data = new Buffer(policy64, 'utf-8');
			key = new Buffer(secretKey, 'utf-8');
			hmac = crypto.createHmac('sha1', key);
			hmac.update(data);
			signature64 = hmac.digest('base64');
			return {
				signature64 : signature64,
				policy64 : policy64
			};
		};

		postToS3 = function (_arg, callback) {
			var AWSAccessKeyId, Filename, acl, addParam, arr, boundary, bucket, buf, ca, contentType, customUrl, data, host, hostname, key, options, policy64, port, protocol, req, req_body, signature64, success_action_status, _ref1;
			AWSAccessKeyId = _arg.AWSAccessKeyId, policy64 = _arg.policy64, signature64 = _arg.signature64, bucket = _arg.bucket, key = _arg.key, data = _arg.data, boundary = _arg.boundary, customUrl = _arg.customUrl, ca = _arg.ca, acl = _arg.acl, success_action_status = _arg.success_action_status, Filename = _arg.Filename, contentType = _arg.contentType;
			if (callback == null) {
				callback = (function () {
				});
			}
			if (customUrl) {
				_ref1 = url.parse(customUrl), protocol = _ref1.protocol, hostname = _ref1.hostname, port = _ref1.port;
				if (protocol !== "https:") {
					return callback(new Error("customUrl must be https://"));
				}
				host = hostname;
				port || (port = 443);
			} else {
				host = "" + bucket + ".s3.amazonaws.com";
				port = 443;
			}
			boundary || (boundary = '----------R46EARkAg4SAXSjufGsb6m');
			buf = function (x) {
				return new Buffer(x);
			};
			arr = [];
			addParam = function (k, v) {
				arr.push(buf('--' + boundary + '\r\n'));
				arr.push(buf('Content-Disposition: form-data; name="' + k + '"\r\n\r\n'));
				return arr.push(buf(v), buf('\r\n'));
			};
			addParam('key', key);
			addParam('acl', acl);
			addParam('success_action_status', success_action_status);
			addParam('Filename', Filename);
			addParam('AWSAccessKeyId', AWSAccessKeyId);
			addParam('Policy', policy64);
			addParam('Signature', signature64);
			addParam('Content-Type', contentType);
			arr.push(buf('--' + boundary + '\r\n'));
			arr.push(buf('Content-Disposition: form-data; name="file"; filename="data"\r\n'));
			arr.push(buf("Content-Length: " + data.length + "\r\n"));
			arr.push(buf('Content-Transfer-Encoding: binary\r\n\r\n'));
			arr.push(data, buf('\r\n'));
			arr.push(buf('--' + boundary + '--'));
			req_body = joinBuffers(arr);
			options = {
				host : host,
				port : port,
				path : '/',
				method : 'POST',
				headers : {
					'Host' : "" + bucket + ".s3.amazonaws.com",
					'Content-Type' : 'multipart/form-data; boundary=' + boundary,
					'Content-Length' : req_body.length
				}
			};
			if (ca) {
				options.ca = ca;
			}
			req = https.request(options, function (res) {
				var _ref2;
				if ((200 <= (_ref2 = res.statusCode) && _ref2 < 300)) {
					return callback(null);
				} else {
					return readText(res, function (text) {
						return callback({
							responseCode : res.statusCode,
							responseText : text
						});
					});
				}
			});
			return req.end(req_body);
		};

		grunt.utils.s3 = {
			postToS3 : postToS3,
			signPolicy : signPolicy
		};

	}).call(this);
}