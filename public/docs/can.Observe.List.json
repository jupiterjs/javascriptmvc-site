c({"name": "can.Observe.List", "type": "class", "comment": "<p><code>new can.Observe.List([items])</code> provides the observable pattern for JavaScript arrays.  It lets you:</p>\n\n<ul>\n<li>change the structure of an array</li>\n<li>listen to changes in the array</li>\n</ul>\n\n<h2>Creating an observe list</h2>\n\n<p>To create an observable list, use <code>new can.Observe.List( ARRAY )</code> like:</p>\n\n<pre><code>var hobbies = new can.Observe.List(\n                ['programming', 'basketball', 'nose picking'])\n</code></pre>\n\n<p>can.Observe.List inherits from [can.Observe], including it's \n[can.Observe.prototype.bind bind], [can.Observe.prototype.each each], and [can.Observe.prototype.unbind unbind] \nmethods.</p>\n\n<p>can.Observe.List is inherited by [can.Model.List].</p>\n\n<h2>Getting and Setting Properties</h2>\n\n<p>Similar to an array, use the index operator to access items of a list:</p>\n\n<pre><code>list = new can.Observe.List([\"a\",\"b\"])\nlist[1] //-&gt; \"b\"\n</code></pre>\n\n<p>Or, use the <code>attr( PROPERTY )</code> method like:</p>\n\n<pre><code>list = new can.Observe.List([\"a\",\"b\"])\nlist.attr(1)  //-&gt; \"b\"\n</code></pre>\n\n<p><strong>WARNING:</strong> while using the index operator with [] is possible, \nit should be noted that changing properties of objects that way\nwill not call bound events to the observed list that would let\nit know that an object in the list has changed. In almost every\ncase you will use [can.Model.static.findAll findAll].</p>\n\n<p>Using the 'attr' method lets Observe know you accessed the \nproperty. This is used by [can.EJS] for live-binding.</p>\n\n<p>Get back a js Array with <code>attr()</code>:</p>\n\n<pre><code>list = new can.Observe.List([\"a\",\"b\"])\nlist.attr()  //-&gt; [\"a\",\"b\"]\n</code></pre>\n\n<p>Change the structure of the array with:</p>\n\n<ul>\n<li>[can.Observe.List::attr attr]</li>\n<li>[can.Observe.List::pop pop]</li>\n<li>[can.Observe.List::push push]</li>\n<li>[can.Observe.List::shift shift]</li>\n<li>[can.Observe.List::unshift unshift]</li>\n<li>[can.Observe.List::splice splice]</li>\n</ul>\n\n<h2>Events</h2>\n\n<p>When an item is added, removed, or updated in a list, it triggers\nevents that can be [can.Observe::bind bind]ed to for changes.</p>\n\n<p>There are 5 types of events: add, remove, set, length, and change.</p>\n\n<h3>add events</h3>\n\n<p>Add events are fired when items are added to the list. Listen \nto them like:</p>\n\n<pre><code>list.bind(\"add\", handler(ev, newVals, index) )\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li><code>newVals</code> - the values added to the list</li>\n<li><code>index</code> - where the items were added</li>\n</ul>\n\n<h3>remove events</h3>\n\n<p>Removes events are fired when items are removed from the list. Listen \nto them like:</p>\n\n<pre><code>list.bind(\"remove\", handler(ev, oldVals, index) )\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li><code>oldVals</code> - the values removed from the list</li>\n<li><code>index</code> - where the items were removed</li>\n</ul>\n\n<h3>set events</h3>\n\n<p>Set events happen when an item in the list is updated. Listen to \nthese events with:</p>\n\n<pre><code>list.bind(\"set\", handler(ev, newVal, index) )\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li><code>newVal</code> - the new value at index</li>\n<li><code>index</code> - where the items were removed</li>\n</ul>\n\n<h3>length events</h3>\n\n<p>Anytime the length is changed a length attribute event is\nfired.</p>\n\n<pre><code>list.bind(\"length\", handler(ev, length) )\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li><code>length</code> - the new length of the array.</li>\n</ul>\n\n<h3>change events</h3>\n\n<p>Change events are fired when any type of change \nhappens on the array.  They get called with:</p>\n\n<pre><code>.bind(\"change\", handler(ev, attr, how, newVal, oldVal) )\n</code></pre>\n\n<p>Where:</p>\n\n<ul>\n<li><code>attr</code> - the index of the item changed</li>\n<li><code>how</code> - how the item was changed (add, remove, set)</li>\n<li><code>newVal</code> - For set, a single item. For add events, an array \nof items. For remove event, undefined.</li>\n<li><code>oldVal</code> - the old values at <code>attr</code>.</li>\n</ul>", "inherits": "can.Observe", "parents": ["canjs"], "construct": "<p>Creates a new observable list from an array</p>", "ret": {"type": "can.observe.list", "description": ""}, "params": {"items...": {"order": 0, "description": "<p>the array of items to create the list with</p>", "name": "items...", "type": "Array", "optional": true}}, "src": {"query": "", "fragment": "", "path": "can/observe/observe.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 848, "children": ["can.Observe.List.prototype"]})