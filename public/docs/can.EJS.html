<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>JavaScriptMVC  - can.EJS</title>
	<meta name="description" content="">
	<meta name="author" content="">

	<link rel="stylesheet" type="text/css" 
		
			href="./static/production.css"
		 />
	<!--[if lt IE 9]>
   <script type="text/javascript" src="./static/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="docs">
	<header>
		<nav class="container">

			<div class="logo-menu">
				<a class="brand" href="./index.html">JavaScriptMVC</a>
			</div>

			<div class="pull-right">
				<div class="bitovi-menu">
					<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
					<ul class="dropdown-menu">
						<li><a href="http://bitovi.com">Bitovi.com</a></li>
						<li><a href="http://bitovi.com/blog/">Blog</a></li>
						<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
						<li><a href="http://bitovi.com/training/">Training</a></li>
						<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
						<li><a href="http://bitovi.com/people/">People</a></li>
						<li><a href="http://bitovi.com/contact/">Contact Us</a></li>
					</ul>
				</div>
			</div>
		</nav>
	</header>

	<div class="container api">
	<nav class="sidebar">
		
		<div class="search-wrapper">
			<div class="search">
				<input type="text"/>
			</div>
		</div>
		
		<ul class="api cascading primary-grouping"> 
	
		
		<li class="search-container active parent">
			<a href="index.html" data-search="JavaScriptMVC">
				JavaScriptMVC
			</a>
		</li>
		
		<li class="search-container active parent">
			<a href="canjs.html" data-search="CanJS">
				CanJS
			</a>
		</li>
		
		
			<li class="search-container active">
			<a href="can.EJS.html" data-search="can.EJS">
				can.EJS
			</a>
			
	<ul>
		
			
				
				
				<li class="search-container">
					<a class="page" href="can.EJS.Helpers.html" data-search="Helpers">
						Helpers
					</a>
				</li>
				
			
			
		
			
				
					
					<li class="heading search-container">
						<span>prototype</span>
						
	<ul>
		
			
				
				
				<li class="search-container">
					<a class="function" href="can.EJS.prototype.render.html" data-search="render">
						render
					</a>
				</li>
				
			
			
		
			
		
			
		
			
		
	</ul>


					</li>
					
				
				
			
			
		
	</ul>


		</li>
		
	
</ul>

	</nav>
	<article class="content docs">
		<section class="title">
			<div class="pull-right">
	<ul class="tags">
		<li>constructor</li>
	</ul>
	<ul class="links">
		
			<li><a href="">source</a></li>
		
		
			
		
		
	</ul>
</div>

<h1>
can.EJS


</h1>

<span class="inherits">&nbsp;</span>

		</section>

		<section class="contents">
		</section>

		<section class="description">
			
		</section>

		

		

		
		<section class="comment">
			<p>EJS provides <strong>live</strong> ERB-style client-side templates. Use EJS 
with <a href="can.view.html">can.view</a> and for live templating use EJS with <a href="can.Observe.html">can.Observe</a>.</p>

<h2>Basic Example</h2>

<p>The following renders a Teacher's name and students into an element.  First, 
create a teacher template in a script tag like:</p>

<pre><code>&lt;script type='text/ejs' id='teacherEJS'&gt;

  &lt;h2 class='&lt;%= teacher.grade &lt; 'c'? "good" : "bad" %&gt;'&gt;
    &lt;%= teacher.name %&gt;
  &lt;/h2&gt;

  &lt;ul&gt;
    &lt;% for(var i =0; i&lt; teacher.students.length; i++){ %&gt;
      &lt;li&gt;&lt;%= teacher.students[i].name %&gt;&lt;/li&gt;
    &lt;% } %&gt;
  &lt;/ul&gt;

&lt;/script&gt;
</code></pre>

<p>Notice the magic tags?  Those are things that look like <code>&lt;% %&gt;</code> and 
<code>&lt;%= %&gt;</code>.  Code between <code>&lt;% %&gt;</code> is run and the return value of code
between <code>&lt;%= %&gt;</code> is inserted into the page.</p>

<p>Next, create a teacher and use can.view to render the template:</p>

<pre><code>var teacher = {
  name : "Mr. Smith",
  grade : "a",
  students : [
    {name : "Suzy"},
    {name : "Payal"},
    {name : "Curtis"},
    {name : "Alexis"}
  ]
};

document.getElementById('teacher')
  .appendChild( can.view("teacherEjs", teacher) )
</code></pre>

<p>This results in HTML like:</p>

<pre><code>&lt;div id='teachers'&gt;
  &lt;h2 class='good'&gt;
    Mr. Smith
  &lt;/h2&gt;

  &lt;ul&gt;
     &lt;li&gt;Suzy&lt;/li&gt;
     &lt;li&gt;Payal&lt;/li&gt;
     &lt;li&gt;Curtis&lt;/li&gt;
     &lt;li&gt;Alexis&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>This is nice, but what if we change properties of the teacher?</p>

<h2>Basic Live Binding Example</h2>

<p>EJS sets up live templating binding when a <a href="can.Observe.html">can.Observe</a>'s properties are read 
via <a href="can.Observe.prototype.attr.html">attr</a> within a magic tag.  To make this template
respond to changes in the teacher data, first rewrite the template
to use the attr method to read properties and <code>list( observeList, cb(item, i) )</code>
to iterate through a list like:</p>

<pre><code>&lt;script type='text/ejs' id='teacherEJS'&gt;

  &lt;h2 class='&lt;%= teacher.attr('grade') &lt; 'c'? "good" : "bad" %&gt;'&gt;
    &lt;%= teacher.attr('name') %&gt;
  &lt;/h2&gt;

  &lt;ul&gt;
    &lt;% list(teacher.students, function(student){ %&gt;
      &lt;li&gt;&lt;%= student.attr('name') %&gt;&lt;/li&gt;
    &lt;% }) %&gt;
  &lt;/ul&gt;

&lt;/script&gt;
</code></pre>

<p><strong>Note:</strong> The end of this page discusses why using <code>list</code> is 
helpful, but it does nothing fancy.</p>

<p>Next, turn your teacher into a <code>new can.Observe(object)</code> and pass
that to <code>can.view</code>:</p>

<pre><code>var teacher = can.Observe({
  name : "Mr. Smith",
  grade : "a"
  students : [
    {name : "Suzy"},
    {name : "Payal"},
    {name : "Curtis"},
    {name : "Alexis"}
  ]
});

document.getElementById('teacher')
  .appendChild( can.view("teacherEjs", teacher) );
</code></pre>

<p>Finally, update some properties of teacher and slap your 
head with disbelief ...</p>

<pre><code>teacher.attr('name',"Prof. Snape")
teacher.attr('grade','f+')
teacher.attr('students').push({
  name : "Harry Potter"
})
</code></pre>

<p>... but don't slap it too hard, you'll need it for building awesome apps.</p>

<h2>Demo</h2>

<p>The following demo shows an EJS template being rendered with observable data. 
It demonstrates live binding to attributes. The template and all data properties 
are editable, so experiment!</p>

<div class='iframe_wrapper' data-iframe-src='can/view/ejs/demo.html' data-iframe-height='1020'></div>

<h2>Magic Tags</h2>

<p>EJS uses 5 types of tags:</p>

<p><strong><code>&lt;% CODE %&gt;</code></strong> - Runs JS Code.</p>

<p>This type of magic tag does not modify the template but is used for JS control statements like for-loops, if/else, switch, etc.  An example:</p>

<pre><code>&lt;% if( items.attr('length') === 0 ) { %&gt;
    &lt;tr&gt;&lt;td&gt;You have no items&lt;/td&gt;&lt;/tr&gt;
&lt;% } else { %&gt;
    &lt;% list(items, function(){ %&gt;
      &lt;tr&gt; .... &lt;/tr&gt;
    &lt;% }) %&gt;
&lt;% } %&gt;
</code></pre>

<p>Variable declarations and control blocks should always be defined in their own dedicated tags. Live binding leverages this hinting to ensure that logic is declared and executed at its intended scope.</p>

<pre><code>&lt;!-- Each statement has its own dedicated EJS tag --&gt;
&lt;% var address = person.attr('address') %&gt;
&lt;% list(items, function() { %&gt;
    &lt;tr&gt; .... &lt;/tr&gt;
&lt;% }) %&gt;
&lt;span&gt;&lt;%= address.attr('street') %&gt;&lt;span&gt;

&lt;!-- This won't work! --&gt;
&lt;%
  var address = person.attr('address');
  list(items, function() {
%&gt;
    &lt;tr&gt; .... &lt;/tr&gt;
&lt;% }) %&gt;
&lt;span&gt;&lt;%= address.attr('street') %&gt;&lt;span&gt;
</code></pre>

<p><strong><code>&lt;%= CODE %&gt;</code></strong> - Runs JS Code and writes the <em>escaped</em> result into the result of the template.</p>

<p>The following results in the user seeing "my favorite element is &lt;blink>BLINK&lt;blink>" and not
<blink>BLINK</blink>.</p>

<pre><code> &lt;div&gt;my favorite element is &lt;%= '&lt;blink&gt;BLINK&lt;/blink&gt;' %&gt;.&lt;/div&gt;
</code></pre>

<p><strong><code>&lt;%== CODE %&gt;</code></strong>  - Runs JS Code and writes the <em>unescaped</em> result into the result of the template.</p>

<p>The following results in "my favorite element is <B>B</B>.". Using <code>&lt;%==</code> is useful
for sub-templates.</p>

<pre><code>     &lt;div&gt;my favorite element is &lt;%== '&lt;B&gt;B&lt;/B&gt;' %&gt;.&lt;/div&gt;
</code></pre>

<p><strong><code>&lt;%% CODE %&gt;</code></strong> - Writes &lt;% CODE %> to the result of the template.  This is very useful for generators.</p>

<pre><code>     &lt;%%= 'hello world' %&gt;
</code></pre>

<p><strong><code>&lt;%# CODE %&gt;</code></strong>  - Used for comments.  This does nothing.</p>

<pre><code>     &lt;%# 'hello world' %&gt;
</code></pre>

<h2>Live Binding</h2>

<p>EJS allows live binding by wrapping magic tag content within a function. When <code>attr()</code> is called 
to update an observable object, these functions are executed to return the new value.</p>

<pre><code>// Suppose an observable "foo":

var foo = can.Observe({
  count: '0'
});

// Suppose also, the above observable is passed to our view:

&lt;%= foo.attr('bar') %&gt;

// EJS locates the magic tag and turns the above into:

function() { return foo.attr('bar'); }

// As "foo" is updated using attr(), this function is called again to
// render the view with the new value.
</code></pre>

<p>This means that each function tag has a closure will reference variables in it's 
parent functions. This can cause problems if you don't understand closures in 
JavaScript. For example, the following binding does not work:</p>

<pre><code>&lt;% for(var i =0; i &lt; items.attr('length'); i++){ %&gt;
  &lt;li&gt;&lt;%= items[i].attr('name') %&gt;&lt;/li&gt;
&lt;% } %&gt;
</code></pre>

<p>This is because it gets turned into:</p>

<pre><code>&lt;% for(var i =0; i &lt; items.attr('length'); i++){ %&gt;
  LIVEBIND( function() { return items[i].attr('name') )
&lt;% } %&gt;
</code></pre>

<p>When the wrapping function is called again, <code>i</code> will 
not be the index of the item, but instead be items.length.</p>

<p>The [can.EJS.Helpers::view view]<code>(observeList,function(item,index,list){})</code> method in EJS should be used to iterate through observe lists:</p>

<pre><code>&lt;% list(items, function(item){ %&gt;
  &lt;li&gt;&lt;%= item.attr('name') %&gt;&lt;/li&gt;
&lt;% }) %&gt;
</code></pre>

<h2>Advanced Live Binding</h2>

<p>Once you get the hang of how EJS works, it makes live-binding of complex
calculations possible.  The following extends a <a href="can.Model.List.html">can.Model.List</a> to suppot a <code>completed</code> method that
returns the total number of completed items in the list.  It can be used in a template like:</p>

<pre><code>&lt;h2&gt;&lt;%= todos.complete() %&gt; Complete Todos &lt;/h2&gt;
</code></pre>

<p>And implemented like:</p>

<pre><code>Todo.List = can.Model.List({
  completed: function() {
    var count = 0;

    this.attr('length');
    this.each(function(i, todo) {
      if(this.attr('completed')) {
        count++;
      }
    });

    return count;
  }
});
</code></pre>

<p><code>completed</code> listens on changes to the list (via <code>this.attr('length')</code>) and 
each item's <code>'completed'</code> property.  EJS keeps track of which observe/attribute pairs are called
by <code>.complete()</code>.  If they change, EJS will automatically unbind.</p>

<p>Adding a "completed" helper function to the todo model list to return the number of completed todos:</p>

<p><strong>Note:</strong> The object passed into the view becomes "this" within the view template.</p>

<pre><code>var todos = Todo.findAll({}); //returns a can.Model.List
can.view('//todo/views/init.ejs', todos)
</code></pre>
		</section>
		

		
	</article>
</div>



	<footer>
		<nav class="container">
			<a class="brand javascriptmvc" href="index.html"></a>
		</nav>
	</footer>
	<script type="text/javascript">
		window.Bitovi = {
			URL: {
				BUILDER: '',
				BUILDER_DATA: '',
				BITHUB: '',
				CDN: ''
			}
		}
		steal = {
			productionId: "production.js",
			executed: ["documentjs/site/static/build/production.css"]
		}
	</script>
	<script type='text/javascript' 
	
		src="./static/steal.production.js"
	
		></script>
</body>

</html>
