c({"name": "can.Observe.prototype.restore", "params": {"restoreAssociations": {"description": "<p>Whether nested objects should also\nbe restored or not. Defaults to false.</p>", "type": "Boolean", "optional": true, "order": 0, "name": "restoreAssociations"}}, "ret": {"description": "<p>The observe instance</p>", "type": "can.Observe"}, "type": "function", "comment": "<p><code>observe.restore([restoreAssociations])</code> restores the observe to the state of the last time\n[can.Observe.prototype.backup] was called if [can.Observe.prototype.isDirty]\nreturns true. If you pass true, <em>restore</em> will also check and restore all nested properties\nand [can.Model] associations.</p>\n\n<pre><code> var recipe = new can.Observe({\n     name : 'Pancakes',\n     ingredients : [{\n         name : \"eggs\",\n         amount : '1'\n     }, {\n         name : \"flour\",\n         amount : '1 cup'\n     }, {\n         name : \"milk\",\n         amount : '1 1/4 cup'\n  }]});\n\n  recipe.backup();\n\n  // Change the attribute of a nested observe\n  recipe.attr('ingredients.0.amount', '2');\n  recipe.attr('name', 'Eggcakes');\n  recipe.attr('name') // -&gt; Eggcakes\n  recipe.attr('ingredients.0.amount') // -&gt; 2\n  recipe.restore(true);\n  recipe.attr('name') // -&gt; Pancakes\n  recipe.attr('ingredients.0.amount') // -&gt; 1\n</code></pre>", "parents": ["can.Observe.backup"], "src": {"query": "", "fragment": "", "path": "can/observe/backup/backup.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 92, "children": []})