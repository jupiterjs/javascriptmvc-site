c({"name": "can.Observe.prototype.attr", "params": {"attr": {"description": "<p>the attribute to read or write.</p>\n\n<pre><code>o.attr( 'name' ) //-&gt; reads the name\no.attr( 'name', 'Justin' ) //-&gt; writes the name\n</code></pre>\n\n<p>You can read or write deep property names.  For example:</p>\n\n<pre><code>o.attr( 'person', { name: 'Justin' } );\no.attr( 'person.name' ) //-&gt; 'Justin'\n</code></pre>", "type": "String", "optional": false, "order": 0, "name": "attr"}, "val": {"description": "<p>if provided, sets the value.</p>", "type": "Object", "optional": true, "order": 1, "name": "val"}}, "ret": {"description": "<p>the observable or the attribute property.</p>\n\n<p>If you are reading, the property value is returned:</p>\n\n<pre><code>o.attr( 'name' ) //-&gt; Justin\n</code></pre>\n\n<p>If you are writing, the observe is returned for chaining:</p>\n\n<pre><code>o.attr( 'name', 'Brian' ).attr( 'name' ) //-&gt; Brian\n</code></pre>", "type": "Object"}, "type": "function", "parents": ["can.Observe.prototype"], "comment": "<p>Get or set an attribute or attributes on the observe.</p>\n\n<pre><code>o = new can.Observe({});\n\n// sets a user property\no.attr( 'user', { name: 'hank' } );\n\n// read the user's name\no.attr( 'user.name' ) //-&gt; 'hank'\n\n// merge multiple properties\no.attr({\n   grade: 'A'\n});\n\n// get properties\no.attr()           //-&gt; {user: {name: 'hank'}, grade: \"A\"}\n\n// set multiple properties and remove absent attrs\no.attr( { foo: 'bar' }, true );\n\no.attr()           //-&gt; {foo: 'bar'}\n</code></pre>\n\n<h2>Setting Properties</h2>\n\n<p><code>attr( PROPERTY, VALUE )</code> sets the observable's PROPERTY to VALUE.  For example:</p>\n\n<pre><code>o = new can.Observe({});\no.attr( 'user', 'Justin' );\n</code></pre>\n\n<p>This call to attr fires two events on <strong>o</strong> immediately after the value is set, the first is a \"change\" event that can be \nlistened to like:</p>\n\n<pre><code>o.bind( 'change', function( ev, attr, how, newVal, oldVal ) {} );\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li>ev - the \"change\" event</li>\n<li>attr - the name of the attribute changed: <code>\"user\"</code></li>\n<li>how - how the attribute was changed: <code>\"add\"</code> because the property was set for the first time</li>\n<li>newVal - the new value of the property: <code>\"Justin\"</code></li>\n<li>oldVal - the old value of the property: <code>undefined</code></li>\n</ul>\n\n<p>\"change\" events are the generic event that gets fired on all changes to an \nobserve's properties. The second event shares the name of the property being changed\nand can be bound to like:</p>\n\n<pre><code>o.bind( 'name', function( ev, newVal, oldVal ) {} );\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li>ev - the \"name\" event</li>\n<li>newVal - the new value of the name property: <code>'Justin'</code></li>\n<li>oldVal - the old value of the name property: <code>undefined</code></li>\n</ul>\n\n<p><code>attr( PROPERTY, VALUE )</code> allows setting of deep properties like:</p>\n\n<pre><code> o = new can.Observe({ person: { name: { first: 'Just' } } });\n o.attr( 'person.name.first', 'Justin' );\n</code></pre>\n\n<p>All property names should be seperated with a <strong>\".\"</strong>.</p>\n\n<p><code>attr( PROPERTIES )</code> sets multiple properties at once and removes\nproperties not in <code>PROPERTIES</code>.  For example:</p>\n\n<pre><code>o = new can.Observe({ first: 'Just', middle: 'B' });\no.attr({\n  first: 'Justin',\n  last: 'Meyer'\n});\n</code></pre>\n\n<p>This results in an object that looks like:</p>\n\n<pre><code>{ first: 'Justin', last: 'Meyer' }\n</code></pre>\n\n<p>Notice that the <code>middle</code> property is removed.  This results in\n3 change events (and the corresponding property-named events) that\nare triggered after all properties have been set:</p>\n\n<table>\n  <tr><th>attr</th><th>how</th><th>newVal</th><th>oldVal</th></tr>\n  <tr>\n       <td>\"first\"</td><td>\"set\"</td><td>\"Justin\"</td><td>\"Just\"</td>\n  </tr>\n  <tr>\n       <td>\"last\"</td><td>\"add\"</td><td>\"Meyer\"</td><td>undefined</td>\n  </tr>\n  <tr>\n       <td>\"middle\"</td><td>\"remove\"</td><td>undefined</td><td>\"B\"</td>\n  </tr>\n</table>\n\n<p><code>attr( PROPERTIES , true )</code> merges properties into existing \nproperties. For example:</p>\n\n<pre><code>o = new can.Observe({ first: 'Just', middle: 'B' });\no.attr({\n  first: 'Justin',\n  last: 'Meyer'\n})\n</code></pre>\n\n<p>This results in an object that looks like:</p>\n\n<pre><code>{ first: 'Justin', middle: 'B', last: 'Meyer' }\n</code></pre>\n\n<p>and results in 2 change events (and the corresponding \nproperty-named events):</p>\n\n<table>\n  <tr><th>attr</th><th>how</th><th>newVal</th><th>oldVal</th></tr>\n  <tr>\n       <td>\"first\"</td><td>\"set\"</td><td>\"Justin\"</td><td>\"Just\"</td>\n  </tr>\n  <tr>\n       <td>\"last\"</td><td>\"add\"</td><td>\"Meyer\"</td><td>undefined</td>\n  </tr>\n</table>\n\n<p>Use [can.Observe::removeAttr removeAttr] to remove an attribute.</p>\n\n<h2>Reading Properties</h2>\n\n<p><code>attr( PROPERTY )</code> returns a property value.  For example:</p>\n\n<pre><code>o = new can.Observe({ first: 'Justin' });\no.attr( 'first' ) //-&gt; \"Justin\"\n</code></pre>\n\n<p>You can also read properties that don't conflict with Observe's inherited\nmethods direclty like:</p>\n\n<pre><code>o.first //-&gt; \"Justin\"\n</code></pre>\n\n<p><code>attr( PROPERTY )</code> can read nested properties like:</p>\n\n<pre><code> o = new can.Observe({ person: { name: { first: 'Justin' } } });\n o.attr( 'person.name.first' ) //-&gt; \"Justin\"\n</code></pre>\n\n<p>If <code>attr( PROPERTY )</code> returns an object or an array, it returns\nthe Observe wrapped object or array. For example:</p>\n\n<pre><code> o = new can.Observe({ person: { name: { first: 'Justin' } } });\n o.attr( 'person' ).attr( 'name.first' ) //-&gt; \"Justin\"\n</code></pre>\n\n<p><code>attr()</code> returns all properties in the observe, for example:</p>\n\n<pre><code>o = new can.Observe({ first: 'Justin' });\no.attr() //-&gt; { first: \"Justin\" }\n</code></pre>\n\n<p>If the observe has nested objects, <code>attr()</code> returns the \ndata as plain JS objects, not as observes.  Example:</p>\n\n<pre><code> o = new can.Observe({ person: { name: { first: 'Justin' } } });\n o.attr() //-&gt; { person: { name: { first: 'Justin' } } }\n</code></pre>", "src": {"query": "", "fragment": "", "path": "can/observe/observe.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 314, "children": []})