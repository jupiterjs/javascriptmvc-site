c({"name": "jquery.controller.listening", "type": "page", "comment": "<p>Controllers make creating and tearing down event handlers extremely\neasy.  The tearingdown of event handlers is especially important\nin preventing memory leaks in long lived applications.</p>\n\n<h2>Automatic Binding</h2>\n\n<p>When a [jQuery.Controller.prototype.setup new controller is created],\ncontoller checks its prototype methods for functions that are named like \nevent handlers.  It binds these functions to the \ncontroller's [jQuery.Controller.prototype.element element] with \nevent delegation.  When\nthe controller is destroyed (or it's element is removed from the page), controller\nwill unbind its event handlers automatically.</p>\n\n<p>For example, each of the following controller's functions will automatically\nbound:</p>\n\n<pre><code>$.Controller(\"Crazy\",{\n\n  // listens to all clicks on this element\n  \"click\" : function(el, ev){},\n\n  // listens to all mouseovers on \n  // li elements withing this controller\n  \"li mouseover\" : function(el, ev){}\n\n  // listens to the window being resized\n  \"{window} resize\" : function(window, ev){}\n})\n</code></pre>\n\n<p>Controller will bind function names with spaces, standard DOM events, and \nevent names in $.event.special.</p>\n\n<p>In general, Controller will know automatically when to bind event handler functions except for \none case - event names without selectors that are not in $.event.special.</p>\n\n<p>But to correct for this, you just need to add the \nfunction to the [jQuery.Controller.static.listensTo listensTo] \nproperty.  Here's how:</p>\n\n<pre><code> $.Controller(\"MyShow\",{\n   listensTo: [\"show\"]\n },{\n   show: function( el, ev ) {\n     el.show();\n   }\n })\n $('.show').my_show().trigger(\"show\");\n</code></pre>\n\n<h2>Callback parameters</h2>\n\n<p>Event handlers bound with controller are called back with the element and the event \nas parameters.  <b>this</b> refers to the controller instance.  For example:</p>\n\n<pre><code>$.Controller(\"Tabs\",{\n\n  // li - the list element that was clicked\n  // ev - the click event\n  \"li click\" : function(li, ev){\n     this.tab(li).hide()\n  },\n  tab : function(li){\n    return $(li.find(\"a\").attr(\"href\"))\n  }\n})\n</code></pre>\n\n<h2>Templated Event Bindings</h2>\n\n<p>One of Controller's most powerful features is templated event \nhandlers.  You can parameterize the event name,\nthe selector, or event the root element.</p>\n\n<h3>Templating event names and selectors:</h3>\n\n<p>Often, you want to make a widget's behavior \nconfigurable. A common example is configuring which event\na menu should show a sub-menu (ex: on click or mouseenter).  The \nfollowing controller lets you configure when a menu should show \nsub-menus:</p>\n\n<p>The following makes two buttons.  One says hello on click, \nthe other on a 'tap' event.</p>\n\n<pre><code>$.Controller(\"Menu\",{\n  \"li {showEvent}\" : function(el){\n    el.children('ul').show()\n  }\n})\n\n$(\"#clickMe\").menu({showEvent : \"click\"});\n$(\"#touchMe\").menu({showEvent : \"mouseenter\"});\n</code></pre>\n\n<p>$.Controller replaces value in <code>{}</code> with \nvalues in a \ncontroller's [jQuery.Controller.prototype.options options]. This means\nwe can easily provide a default <code>showEvent</code> value and create\na menu without providing a value like:</p>\n\n<pre><code>$.Controller(\"Menu\",\n{\n  defaults : {\n    showEvent : \"click\"\n  }\n},\n{\n  \"li {showEvent}\" : function(el){\n    el.children('ul').show()\n  }\n});\n\n$(\"#clickMe\").menu(); //defaults to using click\n</code></pre>\n\n<p>Sometimes, we might might want to configure our widget to \nuse different elements.  The following makes the menu widget's\n<code>button</code> elements configurable:</p>\n\n<pre><code>$.Controller(\"Menu\",{\n  \"{button} {showEvent}\" : function(el){\n    el.children('ul').show()\n  }\n})\n\n$('#buttonMenu').menu({button: \"button\"});\n</code></pre>\n\n<h3>Templating the root element.</h3>\n\n<p>Finally, controller lets you bind to objects outside \nof the [jQuery.Controller.prototype.element controller's element].</p>\n\n<p>The following listens to clicks on the window:</p>\n\n<pre><code>$.Controller(\"HideOnClick\",{\n  \"{window} click\" : function(){\n    this.element.hide()\n  }\n})\n</code></pre>\n\n<p>The following listens to Todos being created:</p>\n\n<pre><code>$.Controller(\"NewTodos\",{\n  \"{App.Models.Todo} created\" : function(Todo, ev, newTodo){\n    this.element.append(\"newTodos.ejs\", newTodo)\n  }\n});\n</code></pre>\n\n<p>But instead of making NewTodos only work with the Todo model,\nwe can make it configurable:</p>\n\n<pre><code>$.Controller(\"Newbie\",{\n  \"{model} created\" : function(Model, ev, newItem){\n    this.element.append(this.options.view, newItem)\n  }\n});\n\n$('#newItems').newbie({\n  model: App.Models.Todo,\n  view: \"newTodos.ejs\"\n})\n</code></pre>\n\n<h3>How Templated events work</h3>\n\n<p>When looking up a value to replace <code>{}</code>,\ncontroller first looks up the item in the options, then it looks\nup the value in the window object.  It does not use eval to look up the\nobject.  Instead it uses [jQuery.String.getObject].</p>\n\n<h2>Subscribing to OpenAjax messages and custom bindings</h2>\n\n<p>The jquery/controller/subscribe plugin allows controllers to listen\nto OpenAjax.hub messages like:</p>\n\n<pre><code>$.Controller(\"Listener\",{\n  \"something.updated subscribe\" : function(called, data){\n\n  }\n})\n</code></pre>\n\n<p>You can create your own binders by adding to [jQuery.Controller.static.processors].</p>\n\n<h2>Manually binding to events.</h2>\n\n<p>The [jQuery.Controller.prototype.bind] and [jQuery.Controller.prototype.delegate]\nmethods let you listen to events on other elements.  These event handlers will\nbe unbound when the controller instance is destroyed.</p>", "title": "Listening To Events", "parents": ["jQuery.Controller"], "src": "jquery/controller/pages/listening.md", "children": []})