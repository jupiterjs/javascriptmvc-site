c({"name": "can.Observe.List.prototype.replace", "params": {"newList": {"description": "<p>The new list to use. If not passed, the list\nwill be emptied.</p>", "type": "can.Observe.List|Array|can.Deferred", "optional": true, "order": 0, "name": "newList"}}, "ret": {"description": "<p>The current list</p>", "type": "can.Observe.List"}, "type": "function", "parents": ["can.Observe.List.prototype"], "comment": "<p>`replace([newList]) replaces the current list with another array,\ncan.Observe.List or a Deferred that resolves to a list:</p>\n\n<pre><code> var list = new can.Observe.List('a','b','c');\n list.replace(['x', 'y']); // -&gt; Fires `remove` and `add` event\n list.serialize() // -&gt; ['x', 'y']\n</code></pre>\n\n<p>This allows you to initialize live-binding Controls like this:</p>\n\n<pre><code> can.Control({\n     init : function () {\n         this.list = new Recipe.List();\n         this.element.html(can.view('list.ejs', this.list));\n         this.list.replace(Recipe.findAll());\n     }\n });\n</code></pre>\n\n<p>Meaning that the list will be automatically populated once the Deferred returned by <code>Recipe.findAll()</code>\nresolves.</p>", "src": {"query": "", "fragment": "", "path": "can/observe/observe.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 1550, "children": []})