c({"name": "can.Construct", "hasChildren": true, "src": "can/construct/construct.md", "line": 13, "children": ["can.Construct.static", "can.Construct.prototype", "can.Construct.proxy", "can.Construct.super"], "type": "class", "comment": "<p>can.Construct provides easy prototypal inheritance for JavaScript by creating constructor\nfunctions that can be used with the <strong>new</strong> keyword. It  is based off John Resig's\n[http://ejohn.org/blog/simple-javascript-inheritance/|Simple JavaScript Inheritance] library.</p>\n\n<h2>Creating Constructor Functions</h2>\n\n<p>To create a constructor function,  call <code>can.Construct( [ NAME, staticProperties, ] instanceProperties )</code>.</p>\n\n<pre><code>var Animal = can.Construct({\n    breathe : function () {\n        console.log('Breathing');\n    }\n});\n</code></pre>\n\n<p><code>Animal</code> is a constructor function and instances of Animal have a <code>breathe()</code> method. We \ncan create a <code>new Animal</code> object and call <code>breathe()</code> on it like:</p>\n\n<pre><code>var man = new Animal();\nman.breathe();\nman instanceof Animal //-&gt; true\n</code></pre>\n\n<p>If you want to create a sub-class (a constructor function that inherits properties from a base constructor function),\ncall the the  base constructor function with the new constructor function's properties:</p>\n\n<pre><code>Dog = Animal({\n    bark : function () {\n        console.log('Woof!');\n    }\n});\n\nvar dog = new Dog;\ndog.bark();\ndog.breathe();\n</code></pre>\n\n<h2>Instantiation</h2>\n\n<p>When a new class instance is created, it calls the class's <code>init</code> method with the arguments passed\nto the constructor function:</p>\n\n<pre><code>var Person = can.Construct({\n    init : function (name) {\n        this.name = name;\n    },\n    speak : function () {\n        return \"I am \" + this.name + \".\";\n    }\n});\n\nvar payal = new Person(\"Payal\");\nconsole.log(payal.speak());\n// -&gt; I am Payal.\n</code></pre>\n\n<h2>Static Inheritance</h2>\n\n<p>If you pass two objects to can.Construct, the first one will be attached directly to the constructor function.\nThis is pretty much the same as static properties in most class based languages.\nYou can access static properties directly on the construct object or in a prototype method by accessing the\n[can.Construct::constructor] using <code>this.constructor</code>. The following example creates a Person construct\nthat increments a counter for each instance created:</p>\n\n<pre><code>var Person = can.Construct({\n    count : 0\n}, {\n    init : function(name) {\n        this.name = name;\n        this.constructor.count++;\n    }\n});\n\nvar justin = new Person('Justin');\nconsole.log(Person.count); // -&gt; 1\n</code></pre>\n\n<h2>Introspection</h2>\n\n<p>Constructor functions are anonymous, meaning that they don't carry any naming or namespace information.\nYou can however pass a namespace string when defining a can.Construct which will make the constructor\nfunction available globally in that namespace and also set the\n[can.Construct.static.shortName], [can.Construct.static.fullName] and [can.Construct.static.namespace]\nstatic properties.</p>\n\n<pre><code>can.Construct(\"Bitovi.Person\", {\n    init : function(name) {\n        this.name = name;\n    }\n});\n\nconsole.log(Bitovi.Person.shortName); // -&gt; 'Person'\nconsole.log(Bitovi.Person.fullName);  //-&gt; 'Bitovi.Person'\nconsole.log(Bitovi.Person.namespace); //-&gt; [Object]\n\nvar person = new Bitovi.Person();\nconsole.log(person.constructor.shortName); // -&gt; 'Person'\n</code></pre>\n\n<h2>Plugins</h2>\n\n<p>can.Construct can be used with these two plugins:</p>\n\n<p>[can.Construct.super]: Adds access to the prototype by adding <code>this._super</code> to overwritten methods</p>\n\n<p>[can.Construct.proxy]: Is a flexible way to create callbacks from constructor functions</p>", "parents": ["canjs"]})