c({"name": "can.Model.static.findAll", "type": "function", "parents": ["can.Model.static"], "comment": "<p><code>findAll( params, success(instances), error(xhr) ) -&gt; Deferred</code> is used to retrieve model \ninstances from the server. Before you can use <code>findAll</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : \"/recipes.json\"\n},{});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>[\n  {\"id\" : 57, \"name\": \"Ice Water\"},\n  {\"id\" : 58, \"name\": \"Toast\"}\n]\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement findAll with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : {\n    url: \"/recipes.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findAll</code> is passed <strong>params</strong> to filter\nthe instances retrieved from the server and it should return a\ndeferred that resolves to an array of model data. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : function(params){\n    return $.ajax({\n      url: '/recipes.json',\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findAll</code>, you can use it to retrieve instances of the model\nlike:</p>\n\n<pre><code>Recipe.findAll({favorite: true}, function(recipes){\n  recipes[0].attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n  // called if an error\n}) //-&gt; Deferred\n</code></pre>\n\n<p>The following API details the use of <code>findAll</code>.</p>", "params": {"params": {"order": 0, "description": "<p>data to refine the results.  An example might be passing {limit : 20} to\nlimit the number of items retrieved.</p>\n\n<pre><code>Recipe.findAll({limit: 20})\n</code></pre>", "name": "params", "type": "Object", "optional": false}, "success(items)": {"order": 1, "description": "<p>called with a [can.Model.List] of model \ninstances.  The model isntances are created from the Deferred's resolved data.</p>\n\n<pre><code>Recipe.findAll({limit: 20}, function(recipes){\n  recipes.constructor //-&gt; can.Model.List\n})\n</code></pre>", "name": "success(items)", "type": "Function", "optional": true}, "error(xhr)": {"order": 2, "description": "<p><code>error</code> is called if the Deferred is rejected with the\nxhr handler.</p>", "name": "error(xhr)", "type": "Function", "optional": false}}, "ret": {"description": "<p>a [can.Deferred Deferred] that <strong>resolves</strong> to\na [can.Model.List] of the model instances and <strong>rejects</strong> to the XHR object.</p>\n\n<pre><code>Recipe.findAll()\n      .then(function(recipes){\n\n      }, function(xhr){\n\n      })\n</code></pre>", "type": "Deferred"}, "src": {"query": "", "fragment": "", "path": "can/model/model.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 358, "children": []})