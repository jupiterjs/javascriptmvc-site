c({"name": "rapidstart", "type": "page", "comment": "<p>This walks through the basics of JavaScriptMVC by building a \nsmal todo app.  Check out the [getstarted Getting Started Guide] \nfor a more in-depth overview.</p>\n\n<h2>Get JavaScriptMVC</h2>\n\n<p>[http://javascriptmvc.com/builder.html Download it] or \n[developwithgit pull it from Git].  JavaScriptMVC (JMVC) is a collection of 5 sub-projects. \nOnce you have JavaScriptMVC, you should have a folder with:</p>\n\n<pre><code>can            - lightweight MVC components\ndocumentjs     - documentation engine\nfuncunit       - testing app\njquery         - useful collections of jQuery plugins\nsteal          - dependency management\njs             - JS command line for Linux/Mac\njs.bat         - JS command line for Windows\nstealconfig.js - configuration file for script loading\n</code></pre>\n\n<p><b>Notice</b>: The folder that has these sub-projects is called the [rootfolder root folder].</p>\n\n<h2>Get JavaScriptMVC running.</h2>\n\n<p>JMVC uses [steal steal/steal.js] for dependency \nmanagement. Steal loads scripts.  To use JavaScriptMVC's \nfeatures like [can.Control] and [can.view],\n'steal' them like:</p>\n\n<pre><code>steal('can/control','can/view/ejs',function(Control, view){\n  //code that uses controller and view goes here\n})\n</code></pre>\n\n<p>To use steal, you need to add the steal script to \nyour page. In the [rootfolder root folder] create a <strong>todos</strong> folder\nand empty <strong>todos.html</strong> and <strong>todos.js</strong> that look like:</p>\n\n<pre><code>ROOT\\\n    can\\\n    documentjs\\\n    jquery\\\n    funcunit\\\n    steal\\\n    todos\\\n      todos.js\n      todos.html\n</code></pre>\n\n<p>To load <em>steal.js</em> and <em>todos.js</em>, make <strong>todos.html</strong> look like:</p>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n  &lt;ul id='todos'&gt;&lt;/ul&gt;\n  &lt;input id='editor'/&gt;\n  &lt;script src='../steal/steal.js?todos/todos.js'&gt;\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Open the page in your browser.  Use a debugger like firebug to see <em>steal.js</em> and <em>todos.js</em> loading.</p>\n\n<h2>steal <code>steal([paths])</code></h2>\n\n<p>[steal] is used to load scripts, styles, even CoffeeScript, LESS\nand templates into your application.  </p>\n\n<p>Paths are assumed to be relative to \nthe [rootfolder root folder]. This means that \nthe following always loads <code>can/construct/construct.js</code> no \nmatter which file is calling steal:</p>\n\n<pre><code>steal('can/construct/construct.js');\n</code></pre>\n\n<p>You can load relative to the current file by adding <code>./</code> to the\nstart of your path like:</p>\n\n<pre><code>steal('./helpers.js')\n</code></pre>\n\n<p>Steal also supports css, allowing you to steal <code>todos/todos.css</code> \nlike:</p>\n\n<pre><code>steal('./todos.css')\n</code></pre>\n\n<p>Because loading paths like <code>can/construct/construct.js</code> is so \ncommon, if you do not provide an extension like <code>.js</code>, steal \nwill append the last folder name and <code>.js</code>. This makes\nthe following load <code>can/construct/construct.js</code>:</p>\n\n<pre><code>steal('can/construct')\n</code></pre>\n\n<p>Steal is an asynchronous loader, so you can't do:</p>\n\n<pre><code>steal('can/construct')\ncan.Construct\n</code></pre>\n\n<p>Instead, do:</p>\n\n<pre><code>steal('can/construct', function(Construct){\n  Construct\n});\n</code></pre>\n\n<p>Steal calls back functions with the return value\nof each module. For example:</p>\n\n<pre><code>steal('can/control', \n      'can/model',\n      function( Control, Model ){\n\n});\n</code></pre>\n\n<p>Stealing the <code>'can'</code> module steals [canjs CanJS's] core files\nand provides the <code>can</code> namespace to the callback function. For\nexample:</p>\n\n<pre><code>steal('can', function(can){\n  can.Model\n  can.Control\n  can.view\n  can.route\n})\n</code></pre>\n\n<p>For this application, we will load CanJS's most\ncommon plugins.  Add the following to <strong>todos.js</strong>:</p>\n\n<pre><code>steal('can',\n      'can/util/fixture',\n      function(can){\n\n})\n</code></pre>\n\n<p>The following goes through each plugin while we build the todos app.</p>\n\n<h2>can.Construct <code>can.Construct([name,] [staticProps,] [prototypeProps])</code></h2>\n\n<p>Constructors made with [can.Construct] are used to create\nobjects with shared properties. It's used by both\n<strong>can.Control</strong> and <strong>can.Model</strong>.</p>\n\n<p>To create a <strong>Constructor function</strong> of your own, call <strong>can.Construct</strong> with the:</p>\n\n<ul>\n<li><strong>staticProperties</strong> that are attached directly to the constructor, and</li>\n<li>instance <strong>prototypeProperties</strong>.</li>\n</ul>\n\n<p><strong>can.Construct</strong> sets up the prototype chain so subclasses can be further extended and sub-classed as far as you like:</p>\n\n<pre><code>steal('can/construct', function(Construct){\n\n  var Todo = Construct({\n    init : function(){},\n\n    author : function(){ ... },\n\n    coordinates : function(){ ... },\n\n    allowedToEdit: function(account) { \n     return true;\n    }\n  });\n\n  var PrivateTodo = Todo({\n    allowedToEdit: function(account) {\n      return account.owns(this);\n    }\n  })\n\n});\n</code></pre>\n\n<p><em>Brief aside on <code>super</code>. If you steal the [can.Construct.super can/construct/super] plugin,  can.Construct provides a <code>_super</code> method to call the function of the same name higher on the prototype chain like:</em></p>\n\n<pre><code>var SecureNote = Todo({\n  allowedToEdit: function(account) {\n    return this._super(account) &amp;&amp; \n       this.isSecure();\n  }\n})\n</code></pre>\n\n<h3>constructor / init <code>new ConstructorFunction(arg1, arg2)</code></h3>\n\n<p>When a constructor is called with the <code>new</code> keyword, <strong>can.Construct</strong> creates \nthe instance and calls [can.Construct.prototype.init] with \nthe arguments passed to <code>new ConstructorFunction(â€¦)</code>.</p>\n\n<pre><code>var Todo = can.Construct({\n  init : function(text) {\n    this.text = text\n  },\n  read : function(){\n    console.log(this.text);\n  }\n})\n\nvar todo = new Todo(\"Hello World\");\ntodo.read()\n</code></pre>\n\n<p><em>Brief aside on <strong>init</strong>.  can.Construct actually calls \n[can.Construct.prototype.setup can.Construct.prototype.setup] before \ninit. <code>setup</code> can be used to change (or normalize) the arguments \npassed to <strong>init</strong>.</em></p>\n\n<h2>Model <code>can.Model(staticProperties, prototypeProperties)</code></h2>\n\n<p>Models are central to any application.  They \ncontain data and logic surrounding it. Extend\n[can.Model can.Model] with your domain specific \nmethods and can.Model provides a set of methods \nfor managing changes.</p>\n\n<p>To create a <strong>Model</strong> constructor, call <strong>can.Model</strong> with the:</p>\n\n<ul>\n<li><strong>staticProperties</strong>, including \n[can.Model.findAll findAll],\n[can.Model.findAll findOne],\n[can.Model.create create],\n[can.Model.update update],\n[can.Model.destroy destroy] properties, and</li>\n<li>prototype instance properties.</li>\n</ul>\n\n<p>Make a Todo model in <strong>todos.js</strong> like the following:</p>\n\n<pre><code>steal('can',\n     'can/util/fixture',\n      function(can){\n\n  Todo = can.Model({\n    findAll : \"GET /todos\",\n    findOne : \"GET /todos/{id}\",\n    create  : \"POST /todos\",\n    update  : \"PUT /todos/{id}\",\n    destroy : \"DELETE /todos/{id}\"\n  },\n  {});\n\n});\n</code></pre>\n\n<p><strong>Note:</strong> We're keeping Todo global so you can try the following commands in your browser:</p>\n\n<h3>new can.Model(attributes)</h3>\n\n<p>Create a todo instance like:</p>\n\n<pre><code>var todo = new Todo({name: \"do the dishes\"});\n</code></pre>\n\n<h3>attr <code>model.attr( name, [value] )</code></h3>\n\n<p>[can.Observe.prototype.attr] reads or sets properties on model instances.</p>\n\n<pre><code>todo.attr('name') //-&gt; \"do the dishes\"\n\ntodo.attr('name', \"wash the dishes\" );\n\ntodo.attr() //-&gt; {name: \"wash the dishes\"}\n\ntodo.attr({name: \"did the dishes\"});\n</code></pre>\n\n<h3>Talking to the server</h3>\n\n<p>Model uses static [can.Model.findAll findAll],\n[can.Model.findAll findOne], [can.Model.create create],\n[can.Model.update update], and [can.Model.destroy destroy]\nmethods to create, read, update and delete \nmodel instances on the server.  </p>\n\n<p>Now you can call methods on Todo that\nmake changes on the server.  For example, \nin your console, try:</p>\n\n<pre><code>Todo.findAll({});\n</code></pre>\n\n<p>In the console, you'll see it make a request \nto <code>GET /todos</code>.</p>\n\n<p>Assuming your server does not have a <code>/todos</code> service,\nthis won't work.  That's ok, we can simulate them with\n[can.fixture].</p>\n\n<h3>can.fixture <code>can.fixture(url, fixture(request, response(...) ) )</code></h3>\n\n<p>Fixtures simulate requests to a specific url.  The <code>fixture</code> function is called with:</p>\n\n<ul>\n<li><strong>request</strong> - request object passed to $.ajax</li>\n<li><strong>response</strong> - response callback that specifies the response</li>\n</ul>\n\n<p>As a shortcut, if the <code>fixture</code> function returns a value, that value\nis used as the response data. For example, the following\nsimulates a <code>GET</code> request to <code>/todos</code>:</p>\n\n<pre><code>can.fixture(\"GET /todos\", function(request, response){\n        return [\n        {id: 1, name: \"wake up\"},\n        {id: 2, name: \"take out trash\"},\n        {id: 3, name: \"do dishes\"}\n    ];\n});\n</code></pre>\n\n<p><code>can.fixture(fixtures)</code> allows you to specify multiple fixtures\nat once. To simulate the todo services, add the following within the\nsteal callback:</p>\n\n<pre><code>// our list of todos\nvar TODOS = [\n    {id: 1, name: \"wake up\"},\n    {id: 2, name: \"take out trash\"},\n    {id: 3, name: \"do dishes\"}\n]; \ncan.fixture({\n  // findAll\n  \"GET /todos\": function(){\n    return TODOS\n  },\n  // findOne\n  \"GET /todos/{id}\": function(orig){\n    return TODOS[(+orig.data.id)-1];\n  },\n  // create\n  \"POST /todos\": function(request){\n    TODOS.push(request.data);\n    return {id: TODOS.length}\n  },\n  // update\n  \"PUT /todos/{id}\": function(){\n    return {};\n  },\n  // destroy\n  \"DELETE /todos/{id}\": function(){\n    return {};\n  }\n});\n</code></pre>\n\n<p>Now you can use Model's ajax methods to CRUD todos.</p>\n\n<h3>findAll <code>findAll( params, success( todos ), error() )</code></h3>\n\n<p>[can.Model.findAll findAll] retrieves multiple todos:</p>\n\n<pre><code>Todo.findAll({}, function( todos ) {\n  console.log( todos );\n})\n</code></pre>\n\n<h3>findOne <code>findOne( params, success( todo ), error() )</code></h3>\n\n<p>[can.Model.findOne findOne] retrieves a single todo:</p>\n\n<pre><code>Todo.findOne({}, function( todo ) {\n  console.log( todo );\n})\n</code></pre>\n\n<h3>save <code>todo.save( success( todo ), error() )</code></h3>\n\n<p>[can.Model::save Save] can <strong>create</strong> \nor <strong>update</strong> instances depending if the \ninstance has already been created or not.</p>\n\n<p>To <strong>create</strong> a todo on the server, create a\ntodo instance and call <strong>save</strong> like the following:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"})\ntodo.save(function(todo){\n  console.log( todo );\n})\n</code></pre>\n\n<p>To <strong>update</strong> a todo on the server, change the attributes\nand call <strong>save</strong> again like the following:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"});\ntodo.save( function(todo){\n  console.log(\"created\", todo );\n\n  todo.attr(\"name\", \"mow my lawn\")\n  todo.save( function( todo ) {\n    console.log(\"updated\", todo );\n  })\n})\n</code></pre>\n\n<h3>destroy <code>todo.destroy( success( todo ), error() )</code></h3>\n\n<p>[can.Model.prototype.destroy Destroy] deletes a \nrecord on the server.  You can do this like:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"});\ntodo.save( function(todo){\n  console.log(\"created\", todo );\n\n  todo.destroy( function( todo ) {\n    console.log(\"destroyed\", todo );\n  })\n})\n</code></pre>\n\n<h3>bind <code>todo.bind( event, handler( ev, todo ) )</code></h3>\n\n<p>Listening to changes in the Model is what MVC is about. Model \nlets you [can.Model::bind bind] to changes on an individual \ninstance or [can.Model.bind all instances]. For example, you can listen to \nwhen an instance is <strong>created</strong> on the server like:</p>\n\n<pre><code>var todo = new Todo({name: \"mow lawn\"});\ntodo.bind('created', function(ev, todo){\n  console.log(\"created\", todo );\n})\ntodo.save()\n</code></pre>\n\n<p>You can listen to anytime an <strong>instance</strong> is created on the server by binding on the model:</p>\n\n<pre><code>Todo.bind('created', function(ev, todo){\n  console.log(\"created\", todo );\n})\n</code></pre>\n\n<p>Model produces the following events on the model constructor and instances whenever a model Ajax request completes:</p>\n\n<ul>\n<li><strong>created</strong> - an instance is created on the server</li>\n<li><strong>updated</strong> - an instance is updated on the server</li>\n<li><strong>destroyed</strong> - an instance is destroyed on the server</li>\n</ul>\n\n<h2>can.view <code>can.view( idOrUrl, data )</code></h2>\n\n<p>[can.view] is used to easily create HTML with\nJS templates. Pass it ...</p>\n\n<ul>\n<li>the <strong>id</strong> of a script tag to use as the content of the template</li>\n<li><strong>data</strong> to pass to the template</li>\n</ul>\n\n<p>... and it returns the rendered result of the template.  For\nexample, add the following to <strong>todos.html</strong>:</p>\n\n<pre><code>&lt;script type='text/ejs' id='todosEJS'&gt;\n  &lt;% for(var i = 0; i &lt; this.length; i++ ){ %&gt;\n    &lt;li&gt;&lt;%= this[i].name %&gt;&lt;/li&gt;\n  &lt;% } %&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>Render a list of todos with:</p>\n\n<pre><code> Todo.findAll( {}, function( todos ){\n     console.log( can.view( 'todosEJS', todos ) );\n });\n</code></pre>\n\n<p>can.view also takes a <strong>url</strong> for a template location.  <strong>Create</strong> a <em>todos/todos.ejs</em> file that \ncontains the following:</p>\n\n<pre><code>&lt;% this.each(function(todo){ %&gt;\n  &lt;li&gt;&lt;%= todo.attr('name') %&gt;&lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<p>Render this with:</p>\n\n<pre><code>Todo.findAll( {}, function( todos ){\n  console.log( can.view( 'todos.ejs', todos ) );\n});\n</code></pre>\n\n<p><strong>can.view</strong> works with [can.EJS] and [can.Mustache].</p>\n\n<h3>stealing templates</h3>\n\n<p>Use <strong>steal</strong> to load and eventually package \ntemplates. Steal <code>todos.ejs</code> in <code>todos.js</code> like:</p>\n\n<pre><code>steal('can',\n      './todos.ejs',\n      'can/util/fixture',\n      function( can, todoEJS ) {\n</code></pre>\n\n<p><code>todosEJS(data)</code> takes data to render the template and returns\na documentFragment. Render <code>todos.ejs</code> like:</p>\n\n<pre><code>Todo.findAll( {}, function( todos ){\n  $('#todos').html( todosEJS( todos ) );\n});\n</code></pre>\n\n<p>To make this work, make sure <code>todos.html</code> has a <code>#todos</code> element like:</p>\n\n<pre><code>&lt;ul id='todos'&gt;&lt;/ul&gt;\n</code></pre>\n\n<h3>Hookup <code>&lt;li &lt;%= (el)-&gt; CODE %&gt; &gt;</code></h3>\n\n<p>[can.view.hookup] lets you provide \n[http://wiki.ecmascript.org/doku.php?id=strawman:arrow<em>function</em>syntax ES5-style arrow function] \ncallbacks on elements in your template.  These callback functions get called after the template has been \ninserted into the DOM. You can call jQuery methods on the element like:</p>\n\n<pre><code>&lt;li &lt;%= ($el) -&gt; $el.fadeIn() %&gt; style='display:none'&gt;\n  &lt;%= this[i].name %&gt;\n&lt;/li&gt;\n</code></pre>\n\n<p>In your code, add a <strong>returning</strong>  magic tag (<code>&lt;%= %&gt;</code>) that \nmatches the <em>arrow function syntax</em>.  The argument passed to the \nfunction will be the jQuery-wrapped element.  </p>\n\n<p>This lets you hookup model data to elements in EJS.  Change <strong>todos.ejs</strong> to:</p>\n\n<pre><code>&lt;% this.each(function(todo){ %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data('todo', todo) %&gt; class='todo'&gt;\n    &lt;%= todo.attr('name') %&gt;\n    &lt;a href=\"javascript://\" class='destroy'&gt;X&lt;/a&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<p>Here we're setting model instance in the element's data and \nadding classes which will allow us to select this element just by knowing model's id.</p>\n\n<h2>can.Control <code>can.Control(staticProps, prototypeProps)</code></h2>\n\n<p>[can.Control] creates organized, memory-leak free, \nrapidly performing, stateful controls. It is used to create \nUI controls like tabs, grids, and contextmenus and used \nto organize them into higher-order business rules \nwith [can.route]. Its serves as both a traditional view \nand a traditional controller.</p>\n\n<p>Let's make a basic todos widget that lists todos and lets \nus destroy them. Add the following to <strong>todos.js</strong>:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element , options ){\n    Todo.findAll({}, function(todos){\n      element.html( todosEJS( todos ) );\n    });\n  }\n})\n</code></pre>\n\n<p>We can create this widget on the <code>#todos</code> element with:</p>\n\n<pre><code>new Todos('#todos', {});\n</code></pre>\n\n<h3>init <code>can.Control.prototype.init(element, options)</code></h3>\n\n<p>[can.Control::init Init] is called when a\nnew Controller instance is created.  It's called with:</p>\n\n<ul>\n<li><strong>element</strong> - The jQuery wrapped element passed to the \n              controller. Control accepts a raw HTMLElement, a CSS selector, or a NodeList.  This is set as <strong>this.element</strong> on the control instance.</li>\n<li><strong>options</strong> - The second argument passed to new Control, extended with\n              the Control's static <strong>defaults</strong>. This is set as \n              <strong>this.options</strong> on the controller instance.</li>\n</ul>\n\n<h3>Listening to events</h3>\n\n<p>Control automatically binds prototype methods that look\nlike event handlers.  Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element , options ){\n    Todo.findAll({}, function(todos){\n      element.html( todosEJS( todos ) );\n    });\n  },\n  \"li click\": function(li, event){\n    console.log(\"You clicked\", li.text() )\n\n    // let other controls know what happened\n    li.trigger('selected', li.data('todo') );\n  }\n});\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The NodeList of a single <strong>element</strong> that was clicked</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind event handlers.</p>\n\n<p>To destroy a todo when it's <code>&lt;a href='javascript:// class='destroy'&gt;</code> link is clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element ){\n    Todo.findAll({}, function(todos){\n      element.html( todosEJS( todos ) );\n    });\n  },\n  \"li click\": function(li){\n    li.trigger('selected', li.data('todo') );\n  },\n  \"li .destroy click\": function(el, ev){\n    // get the li element that has the model\n    var li = el.closest('li');\n\n    // get the model and destroy it\n    li.data('todo').destroy();\n  }\n})\n</code></pre>\n\n<p>Notice that when a todo instance is destroyed, it is\nautomatically removed from the page. This is live-binding\nin action and it is AMAZING!</p>\n\n<p>It works because [can.EJS] live-binds to [can.Observe can.Observe]s \nand [can.Observe.List can.Observe.List]s. When a List or\nObserve changes, EJS will update the DOM to reflect the \nchanges. <code>todos</code> is a [can.Model.List] which inherits from\n[can.Observe.List] and each <code>todo</code> is a [can.Model] which\ninherits from [can.Observe].</p>\n\n<p>When the <code>todo</code> is destroyed, it removes that instance from\n<code>todos</code>. When <code>todos</code> is updated, the page is updated.</p>\n\n<h3>Templated Event Handlers <code>\"{objectName}\" event</code></h3>\n\n<p>can.Control can bind to objects other than <code>this.element</code> with templated \nevent handlers. This is <strong>critical</strong>\nfor avoiding memory leaks that are so common \namong MVC applications.  </p>\n\n<p>When can.Control sees a method like <code>\"{objectName} event\"</code>, it looks \nfor <code>objectName</code> on the control's options (<code>this.options</code>) and then \nthe <code>window</code>.</p>\n\n<p>For example <code>\"{todo} updated\"</code> listens to updated events on\nthe todo passed the following <code>Editor</code> control.</p>\n\n<pre><code>Editor = can.Control({\n  init: function(){\n    this.setName();\n  },\n  setName : function(){\n    this.element.val(this.options.todo.name);\n  },\n  \"{todo} updated\" : function(){\n    this.setName();\n  },\n  // when the input changes\n  // update the todo instance\n  \"change\" : function(){\n    var todo = this.options.todo\n    todo.attr('name',this.element.val() )\n    todo.save();\n  }\n});\n\nvar todo = new Todo({id: 6, name: \"trash\"});\n\nvar editor = new Editor(\"#editor\",{todo: todo});\n</code></pre>\n\n<p>To make this work, make sure <code>todos.html</code> has an \"#editor\" element:</p>\n\n<pre><code>&lt;input id='editor' type='text'/&gt;\n</code></pre>\n\n<p>When the \"#editor\" element is removed, or <code>editor</code> is destroyed,\ncan.Control will stop listening to <code>todo</code>'s updated event, freeing memory\nfor garbage collection.</p>\n\n<h3>destroy <code>controller.destroy()</code></h3>\n\n<p>[can.Control.prototype.destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var editor = new Editor(\"#todos\")\neditor.destroy();\n</code></pre>\n\n<p>When a controller's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Editor(\"#editor\")\n$(\"#editor\").remove();\n</code></pre>\n\n<p>All event handlers bound with can.Control are unbound when \nthe control is destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible to write leaking applications. An application \nthat uses only templated event handlers on controls within the body could free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h3>on <code>control.on()</code></h3>\n\n<p>[can.Control.prototype.on] function rebinds \nall event handlers. The following adds a <code>todo</code> method to Editor that\nallows it to switch which todo it edits:</p>\n\n<pre><code>Editor = can.Control({\n  todo: function(todo){\n    this.options.todo =  todo;\n    this.on();\n    this.setName();\n  },\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName: function(){\n    this.element.val(this.options.todo.name);\n  },\n  // listen for changes in the todo\n  // and update the input\n  \"{todo} updated\" : function(){\n    this.setName();\n  },\n  // when the input changes\n  // update the todo instance\n  \"change\" : function(){\n    var todo = this.options.todo\n    todo.attr('name',this.element.val() )\n    todo.save();\n  }\n});\n\nvar todo1= new Todo({id: 6, name: \"trash\"}),\n    todo2 = new Todo({id: 6, name: \"dishes\"});\n\n// create the editor;\nvar editor = new Editor(\"#editor\");\n\n// show the first todo\neditor.todo(todo1);\n\n// switch it to the second todo\neditor.todo(todo2);\n</code></pre>\n\n<h2>Routing</h2>\n\n<p>[can.route] is the core of CanJS's \nrouting functionality. It is a [can.Observe] that\nupdates <code>window.location.hash</code> when its properties change\nand updates its properties when <code>window.location.hash</code> \nchanges. It allows very sophisticated routing behavior ... too\nsophisticated for this guide. But, it also handles \nthe basics with ease.  </p>\n\n<p>Listen to routes in controls with special \"route\" events like:</p>\n\n<pre><code>var Routing = can.Control({\n  \"route\" : function(){\n    // matches empty hash, #, or #!\n  },\n  \"todos/:id route\" : function(data){\n    // matches routes like #!todos/5\n  }\n})\n\n// create routing controller\nnew Routing(document.body);\n</code></pre>\n\n<p><code>route</code> methods get called back with \nroute <strong>data</strong>.  The empty <code>\"route\"</code> will be called \nwith no data. But, <code>\"todos/:id route\"</code> will be called \nwith data like: <code>{id: 6}</code>.</p>\n\n<p>We can update the route by changing can.route's data like:</p>\n\n<pre><code>can.route.attr('id','6') // location.hash = #!todos/6\n</code></pre>\n\n<p>Or we can set the hash ourselves like</p>\n\n<pre><code>var hash = can.route.url({id: 7}) // #!todos/7\nlocation.hash = hash;\n</code></pre>\n\n<p>The following enhances the Routing control to listen for\n<code>\".todo selected\"</code> events and update <code>can.route</code>.  When the\ncan.route changes, it retrieves the todo from the server\nand updates the editor widget.</p>\n\n<pre><code>Routing = can.Control({\n  init : function(){\n    this.editor = new Editor(\"#editor\")\n    new Todos(\"#todos\");\n  },\n  // the index page\n  \"route\" : function(){\n     $(\"#editor\").hide();\n  },\n  \"todos/:id route\" : function(data){\n    $(\"#editor\").show();\n    Todo.findOne(data, $.proxy(function(todo){\n      this.editor.todo(todo);\n    }, this))\n  },\n  \".todo selected\" : function(el, ev, todo){\n    can.route.attr('id',todo.id);\n  }\n});\n\n// create routing controller\nnew Routing(document.body);\n</code></pre>\n\n<p>The <strong>Routing</strong> control is a traditional controller. It coordinates\nbetween the <code>can.route</code>, <code>Editor</code> and <code>Todos</code>.  <code>Editor</code> and <code>Todos</code>\nare traditional views, consuming models.</p>\n\n<p>If you can understand this, you understand \neverything. Congrats!  [//tutorials/rapidstart/todos.html See it in action].</p>\n\n<h2>FuncUnit</h2>\n\n<p>JavaScriptMVC uses [FuncUnit] for testing.  FuncUnit provides an API \nfor writing functional tests that simulate clicks and keypresses a user would make.</p>\n\n<p>To create a FuncUnit test:</p>\n\n<ul>\n<li>Create a test file that steals funcunit and</li>\n<li>Create a test.html page that steals your test file</li>\n</ul>\n\n<p>In the <strong>todos</strong> directory, make test.html and add the following HTML:</p>\n\n<pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;script src='../steal/steal.js?todos/todos_test.js'&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Now make <strong>todos_test.js</strong> and add the following:</p>\n\n<pre><code>steal('funcunit', function(S){\n\n  module('todos')\n\n  test('todos test', function(){\n    ok(true, \"the test loads\");\n  })\n\n})\n</code></pre>\n\n<p>Open <strong>test.html</strong> in your browser.  One test passes.</p>\n\n<h3>Writing a test</h3>\n\n<p><code>S</code> is FuncUnit.  FuncUnit's API is very similar to jQuery's (hence the S). Tell \nthe test to open the todos page using [FuncUnit.open S.open]:</p>\n\n<pre><code>S.open(\"//todos/todos.html\");\n</code></pre>\n\n<p>Once the page is open, select the first todo and click it:</p>\n\n<pre><code>S(\".todo:first\").click();\n</code></pre>\n\n<p>Selecting a todo will set the input element's value to the first todo's name. Wait \nfor this using a [funcunit.waits wait] command:</p>\n\n<pre><code>S(\"#editor\").val(\"wake up\", \"First Todo added correctly\");\n</code></pre>\n\n<p>The second parameter is an assertion message.</p>\n\n<p>Replace the test code within the steal callback with the following:</p>\n\n<pre><code>module('todos', {\n  setup: function(){\n    S.open(\"//todos/todos.html\");\n  }\n})\n\ntest('edit first todo', function(){\n  S(\".todo:first\").click();\n  S(\"#editor\").val(\"wake up\", \"First Todo added correctly\");\n})\n</code></pre>\n\n<p>Reload [//tutorials/rapidstart/test.html test.html]. You'll \nsee the page open and run the test in a separate window.</p>\n\n<h3>Test Coverage</h3>\n\n<p>You can see which parts of your app are covered by your tests and which \nparts need more testing using the [steal.instrument steal/instrument] plugin.</p>\n\n<p>To add coverage, add the following code to the very bottom of stealconfig.js:</p>\n\n<pre><code>steal('steal/instrument', function(instrument){\n  instrument({\n    ignores: [\"jquery\",\"can\",\"funcunit\",\"steal\",\n            \"*/test\",\"*_test.js\",\"*funcunit.js\"]\n  })\n})\n</code></pre>\n\n<p>Reload [//tutorials/rapidstart/test.html test.html]. When the tests are done, you'll see \noverall coverage stats.</p>\n\n<p><img class='image_tag' src='tutorials/images/coverage1.png' /></p>\n\n<p>Click the filename to see what lines did and didn't run.</p>\n\n<p><img class='image_tag' src='tutorials/images/coverage2.png' /></p>\n\n<h3>Automation</h3>\n\n<p>To run these tests automated, run the following from the console:</p>\n\n<pre><code>./js funcunit/open/selenium todos/test.html\n</code></pre>\n\n<p>FuncUnit supports [funcunit.integrations integration] with CI tools \nlike [funcunit.jenkins Jenkins], build tools like [funcunit.maven maven], \nand running via the [funcunit.phantomjs PhantomJS] headless browser.</p>", "title": "Rapid Start", "parents": ["tutorials"], "order": 1, "src": "tutorials/rapidstart/rapidstart.md", "children": []})