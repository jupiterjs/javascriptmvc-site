c({"name": "can.fixture.store", "type": "function", "comment": "<p><code>can.fixture.store(count, generator(index,items))</code> is used\nto create a store of items that can simulate a full CRUD service. Furthermore,\nthe store can do filtering, grouping, sorting, and paging.</p>\n\n<h2>Basic Example</h2>\n\n<p>The following creates a store for 100 todos:</p>\n\n<pre><code>var todoStore = can.fixture.store(100, function(i){\n  return {\n       id: i,\n    name: \"todo number \"+i,\n    description: \"a description of some todo\",\n    ownerId: can.fixture.rand(10)\n  }\n})\n</code></pre>\n\n<p><code>todoStore</code>'s methods can be used for the response to a REST service like:</p>\n\n<pre><code> can.fixture({\n      'GET /todos':         todoStore.findAll,\n   'GET /todos/{id}':    todoStore.findOne,\n   'POST /todos':        todoStore.create,\n   'PUT /todos/{id}':    todoStore.update,\n   'DELETE /todos/{id}': todoStore.destroy\n });\n</code></pre>\n\n<p>These fixtures, combined with a [can.Model] that connects to these services like:</p>\n\n<pre><code> var Todo = can.Model({\n     findAll : 'GET /todos',\n     findOne : 'GET /todos/{id}',\n     create  : 'POST /todos',\n     update  : 'PUT /todos/{id}',\n     destroy : 'DELETE /todos/{id}'\n }, {});\n</code></pre>\n\n<p>... allows you to simulate requests for all of owner 5's todos like:</p>\n\n<pre><code>Todo.findAll({ownerId: 5}, function(todos){\n\n})\n</code></pre>\n\n<h2>Simulated Service</h2>\n\n<p><code>can.fixture.store</code>'s [can.fixture.store.findAll findAll],\n[can.fixture.store.findOne findOne],\n[can.fixture.store.findOne create],\n[can.fixture.store.findOne update], and\n[can.fixture.store.findOne destroy] methods are used to\nsimulate a REST service that </p>\n\n<h2>With can.ajax</h2>\n\n<pre><code>//makes a nested list of messages\ncan.fixture.store([\"messages\",\"message\"], 1000,\n function(i, messages){\n  return {\n    subject: \"This is message \"+i,\n    body: \"Here is some text for this message\",\n    date: Math.floor( new Date().getTime() ),\n    parentId : i &lt; 100 ? null : Math.floor(Math.random()*i)\n  }\n})\n//uses the message fixture to return messages limited by\n// offset, limit, order, etc.\ncan.ajax({\n  url: \"messages\",\n  data: {\n     offset: 100,\n     limit: 50,\n     order: [\"date ASC\"],\n     parentId: 5},\n   },\n   fixture: \"-messages\",\n   success: function( messages ) {  ... }\n});\n</code></pre>\n\n<h2>With can.Model</h2>\n\n<p><code>can.fixture.make</code> returns a model store that offers <code>findAll</code>, <code>findOne</code>, <code>create</code>,\n<code>update</code> and <code>destroy</code> fixture functions you can map to a [can.Model] Ajax request.\nConsider a model like this:</p>\n\n<p>And an unnamed generated fixture like this:</p>\n\n<pre><code> var store = can.fixture.make(100, function(i) {\n     return {\n         id : i,\n         name : 'Todo ' + i\n     }\n });\n</code></pre>\n\n<p>You can map can.Model requests using the return value of <code>can.fixture.make</code>:</p>", "parents": ["can.fixture"], "params": {"types": {"order": 0, "description": "<p>An array of the fixture names or the singular fixture name.\nIf an array, the first item is the plural fixture name (prefixed with -) and the second\nitem is the singular name.  If a string, it's assumed to be the singular fixture name.  Make\nwill simply add s to the end of it for the plural name. If this parameter is not an array\nor a String the fixture won't be added and only return the generator object.</p>", "name": "types", "type": "Array|String", "optional": false}, "count": {"order": 1, "description": "<p>the number of items to create</p>", "name": "count", "type": "Number", "optional": false}, "make": {"order": 2, "description": "<p>a function that will return the JavaScript object. The\nmake function is called back with the id and the current array of items.</p>", "name": "make", "type": "Function", "optional": false}, "filter": {"order": 3, "description": "<p>(optional) a function used to further filter results. Used for to simulate\nserver params like searchText or startDate.\nThe function should return true if the item passes the filter,\nfalse otherwise. For example:</p>\n\n<pre><code>function(item, settings){\n  if(settings.data.searchText){\n       var regex = new RegExp(\"^\"+settings.data.searchText)\n      return regex.test(item.name);\n  }\n}\n</code></pre>", "name": "filter", "type": "Function", "optional": false}}, "ret": {"description": "<p>A generator object providing fixture functions for <em>findAll</em>, <em>findOne</em>, <em>create</em>,\n<em>update</em> and <em>destroy</em>.</p>", "type": "Object"}, "src": {"query": "", "fragment": "", "path": "can/util/fixture/fixture.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 353, "children": ["can.fixture.store.findAll", "can.fixture.store.findOne", "can.fixture.store.update", "can.fixture.store.destroy", "can.fixture.store.create", "can.fixture.store.find", "can.fixture.store.reset"]})