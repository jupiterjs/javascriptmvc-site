c({"name": "can.compute", "type": "class", "comment": "<p><code>can.compute( getterSetter, [context] ) -&gt; compute</code> returns a computed method that represents \nsome value.  A <code>compute</code> can can be:</p>\n\n<ul>\n<li><strong>read</strong> - by calling the method like <code>compute()</code></li>\n<li><strong>updated</strong> - by passing a new value like <code>compute( \"new value\" )</code></li>\n<li><strong>listened</strong> to for changes - like <code>compute.bind( \"change\", handler )</code></li>\n</ul>\n\n<p>The value maintained by a <code>compute</code> can represent:</p>\n\n<ul>\n<li>A <strong>static</strong> JavaScript object or value like <code>{foo : 'bar'}</code> or <code>true</code>.</li>\n<li>A <strong>composite</strong> value of one or more [can.Observe] property values.</li>\n<li>A <strong>converted value</strong> derived from another value.</li>\n</ul>\n\n<p>Computes are an abstraction for some value that can be changed. [can.Control]s that \naccept computes (or convert params to computes) can be easily hooked up to \nany data source and be live widgets (widgets that update themselves when data changes).</p>\n\n<h2>Static values</h2>\n\n<p><code>can.compute([value])</code> creates a <code>computed</code> with some value.  For example:</p>\n\n<pre><code>// create a compute\nvar age = can.compute(29);\n\n// read the value\nconsole.log(\"my age is currently\", age());\n\n// listen to changes in age\nage.bind(\"change\", function(ev, newVal, oldVal){\n  console.log(\"my age changed from\",oldVal,\"to\",newVal)\n})\n// update the age\nage(30);\n</code></pre>\n\n<p>Notice that you can <strong>read</strong>, <strong>update</strong>, \nand <strong>listen</strong> to changes in any single value.</p>\n\n<p><em>NOTE: [can.Observe] is similar to compute, but used for objects with multiple properties.</em></p>\n\n<h2>Composite values</h2>\n\n<p>Computes can represent a composite value of one \nor more <code>can.Observe</code> properties.  The following\ncreates a fullName compute that is the <code>person</code>\nobserve's first and last name:</p>\n\n<pre><code>var person = new can.Observe({\n  first : \"Justin\",\n  last : \"Meyer\"\n});\nvar fullName = can.compute(function(){\n  return person.attr(\"first\") +\" \"+ person.attr(\"last\")\n})\n</code></pre>\n\n<p>Read from fullName like:</p>\n\n<pre><code>fullName() //-&gt; \"Justin Meyer\"\n</code></pre>\n\n<p>Listen to changes in fullName like:</p>\n\n<pre><code>fullName.bind(\"change\", function(ev, newVal, oldVal){\n\n})\n</code></pre>\n\n<p>When an event handler is bound to fullName it starts\ncaching the computes value so additional reads are faster!</p>\n\n<h3>Computes with prototype functions</h3>\n\n<p>To make a compute of an object's prototype method,\npass the method and the context the function should be called with\nto <code>can.compute</code>:</p>\n\n<pre><code>var Person = can.Construct({\n  fullName: function(){\n    return this.attr('first')+' '+this.attr('last')\n  }\n});\n\nvar josh = new Person({ first: \"Josh\",  last: \"Dean\" }),\n\n    fullName = can.compute(josh.fullName, josh);\n</code></pre>\n\n<h2>Converted values</h2>\n\n<p><code>can.compute( getterSetter( [newVal] ) )</code> can be used to convert one observe's value into\nanother value.  For example, a <code>PercentDone</code> widget might accept\na compute that needs to have values from <code>0</code> to <code>100</code>, but your project's\nprogress is given between <code>0</code> and <code>1</code>. Pass that widget a compute!</p>\n\n<pre><code>var project = new can.Observe({\n  progress :  0.5\n});\nvar percentage = can.compute(function(newVal){\n  // are we setting?\n  if(newVal !=== undefined){\n    project.attr(\"progress\", newVal / 100)  \n  } else {\n    return project.attr(\"progress\") * 100;  \n  }\n})\n\n// We can read from percentage.\npercentage() //-&gt; 50\n\n// Write to percentage,\npercentage(75)\n// but it updates project!\nproject.attr('progress') //-&gt; 0.75\n\n// pass it to PercentDone\nnew PercentDone({\n  val : percentage\n})\n</code></pre>\n\n<h2>Using computes in building controls.</h2>\n\n<p>The following sudo-code slider cross binds to the \npercent compute. When the drag ends, it updates the\npercent compute.  If the compute changes, it updates\nthe slider's position:  </p>\n\n<pre><code>// A sudo-slider\nvar Slider = can.Control({\n  \".slider dragend\": function(){\n    var percent = this.calculatePercent();\n    this.options.percent(percent)\n  },\n  \"{percent} change\": function(value, ev, newVal){\n    // update position of slider to newVal\n  },\n  calculatePercent: function(){\n    // check .slider's position and return a percent\n  }\n});\n\nnew Slider(\"#slider\", {percent: percent});\n</code></pre>\n\n<p>Widgets that listen to data changes and automatically update \nthemselves kick ass. It's what the V in MVC is all about.  </p>\n\n<p>However, some enironments don't have observeable data. In an ideal\nworld, you'd like to make your widgets still useful to them.</p>\n\n<p><code>can.compute</code> lets you have your cake and eat it too. Simply convert\nall options to compute.  Provide methods to update the compute\nvalues and listen to changes in computes.  Lets see how that\nlooks with <code>PercentDone</code>:</p>\n\n<pre><code>var PercentDone = can.Control({\n  init : function(){\n    this.options.val = can.compute(this.options.val)\n    // rebind event handlers\n    this.on();\n    this.updateContent();\n  },\n  val: function(value){\n       return this.options.val(value)\n  },\n  \"{val} change\" : \"updateContent\",\n  updateContent : function(){\n    this.element.html(this.options.val())\n  }\n})\n</code></pre>", "parents": ["can.util"], "src": {"query": "", "fragment": "", "path": "can/observe/compute/compute.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 125, "children": ["can.compute.isComputed", "can.compute.bind", "can.compute.unbind"]})