<head>
	<title>JavaScriptMVC</title>
	<link rel="stylesheet" type="text/css" href="../documentjs/jmvcdoc/style.css">
	<link rel="shortcut icon" href="../documentjs/jmvcdoc/images/favicon.ico">
<link rel="stylesheet" href="file:////opt/local/share/java/tomcat6/webapps/jmvc31/jmvcdoc/style.css" type="text/css"></head><body>
<div id="documentation">
	<div id="top">
		<div class="topCorner">
			<div class="right"></div>
			<div class="left"></div>
		</div>
		<div class="content">
			<div id="searchRoundCorners">
				<input id="search" type="input" class="jmvcdoc_search">
			</div>
			<div id="defaults">
				<ul id="menu" class="ui-menu">
					<li class="ui-menu-item">
						<a class="menuLink" href="#&amp;search=core"><span class="menuSpan">Core</span></a>
					</li>
					<li class="ui-menu-item">
						<a class="menuLink" href="#favorites"><span class="menuSpan">Favorites</span></a>
					</li>
					<li class="ui-menu-item">
						<a class="menuLink" href="../follow.html" title="Follow"><span class="menuSpan red">Follow</span></a>
					</li>
					<li class="ui-menu-item">
						<a class="menuLink" href="../contribute.html" title="Contribute"><span class="menuSpan red">Contribute</span></a>
					</li>
					<li class="ui-menu-item">
						<a class="menuLink" href="../code.html" title="Code"><span class="menuSpan red">Code</span></a>
					</li>
				</ul>
			</div>
			<div class="logo-text"><a href="http://javascriptmvc.com"><img src="../documentjs/jmvcdoc/images/logo80x30.png" class="logo-image"></a></div>
		</div>
		<div class="bottomCorner">
			<div>&nbsp;</div>
		</div>
	</div>
	<div id="bottom">
		<div id="nav" class="jmvcdoc_nav">


	<div id="selected">
		    
				
		<div class="content">
			    <a href="#!" class="selected choice page" style="padding-left: 20px">
			    	
					JavaScriptMVC
					
				</a>
				
		</div>
			
		<div class="spacer"><div>&nbsp;</div></div>
			
			
				
		<div class="content">
			    <a href="#!examples" class="selected choice page" style="padding-left: 20px">
			    	
						<span class="remove" title="close"></span>
					
					Examples
					
				</a>
				
		</div>
			
			
	</div>

<div id="results" style="display: block">
	<div class="content">
	    
			
		    <a href="#!srchr" class="result choice page" style="padding-left: 20px">
		    	Srchr
			</a>
			
		
			
		    <a href="#!contacts" class="result choice page" style="padding-left: 20px">
		    	Contacts
			</a>
			
		
			
		    <a href="#!playermx" class="result choice page" style="padding-left: 20px">
		    	PlayerMX
			</a>
			
		
			
		    <a href="#!todo" class="result choice page open" style="padding-left: 20px">
		    	Todo
			</a>
			
		
	</div>
</div>


</div>
		<div id="doc_container">
			<div id="doc" class="jmvcdoc_content">
<div class="top">
	<div class="content">
	    <h1>Todo&nbsp;
	    	<span class="page type"><span class="typeEnd">page</span></span>&nbsp;
	    	<span class="favorite favoriteoff">&nbsp;&nbsp;&nbsp;</span></h1>
	    
	    
	    
		
		
	</div>
</div>


<h2>Introduction</h2>

<p>In this guide, we're going to be installing and walking through the simplest <a href="http://javascriptmvc.com/">JavaScriptMVC</a>
application imaginable -- a TODO list manager.</p>

<p>Let's get started.</p>

<h2>Setup</h2>

<p>First, <a href="https://github.com/jupiterjs/todo">clone</a> the application from our repository at GitHub, and initialize all
the necessary submodules. The following commands will get you up and running:</p>

<pre><code class=" javascript">$ git clone https:<span class="comment">//github.com/jupiterjs/todo</span>
$ cd todo
$ git submodule update --init
</code></pre>

<p>This bundle now contains everything you need to run the application locally. Since we have has no server-side
functionality, you should now be able to open the <code>todo/todo.html</code> file in your browser and see it in action. The
interface is extremely simple. Try adding a couple TODO items, and then clear them by checking the boxes and
clicking on the "Clear completed items" link. That's all there is to it.</p>

<h2>Structure</h2>

<p>Let's take a look at the anatomy of our application:</p>

<pre><code class=" javascript">/todo [top-level, the GitHub repo]
  /jquery
    /class
    /controller
    /model
    /view
    jquery.js
    ...
  /steal
    /build
    /generate
    js
    js.bat
    steal.js
    ...
  /funcunit
    /qunit
      qunit.js
      ...
    /scripts
    /test
    funcunit.html
    funcunit.js
    qunit.html
    ...
  /todo
    /scripts
    /test
    funcunit.html
    qunit.html
    todo.css
    todo.html
    todo.js
    ...
</code></pre>

<p>Breaking it down:</p>

<ul>
<li>The <code>jquery</code> folder is where (unsurprisingly) the jQuery library and the JavaScriptMVC framework live. JavaScriptMVC
consists of powerful abstractions like <a href="#!jQuery.Class">$.Class</a>, <a href="#!jQuery.Model">$.Model</a>, <a href="#!jQuery.Controller">$.Controller</a>,
and <a href="#!jQuery.View">$.View</a>, as well as numerous helpful jQuery plugins like <code>resize</code>, <code>destroyed</code>, <code>closest</code>, <code>cur_styles</code>,
and <code>route</code> -- all designed to enhance your life as a JavaScript developer.</li>
<li>The <code>steal</code> folder houses the Steal dependency management system, which is what makes it possible to keep your project
organized during development, and compact and fast in production. Steal has two main responsibilities: As a JavaScript
library, it facilitates on-demand loading of any resources (scripts, stylesheets, templates, or even user-defined
content) your application requires. As a command line utility, it takes care of bundling, compressing, and optimizing
your application for deployment.</li>
<li>The FuncUnit testing framework lives in the <code>funcunit</code> folder -- think jQuery's excellent Qunit framework plus Selenium
and headless (Env.js) support. Basically, qUnit on steroids.</li>
<li>Lastly, our application files will live in the <code>todo</code> folder.</li>
</ul>

<h2>Architecture</h2>

<p>The <a href="">Model-View-Controller Pattern</a> (which we'll be referring to from here on out as MVC) is a well-established
architectural pattern in software engineering. Without going into too much detail, it states that there should be a clear
separation of concerns between the part of the system that represents the application domain (Model), the part that
renders the domain for user interaction (View), and the part that coordinates between the two (Controller).</p>

<p>Since our application consists of only one model, one controller, and a handful of templates, we're going to just keep all
our code in the <code>todo.js</code> and <code>todo.html</code> files. Ordinarily in a JavaScriptMVC application, to make our project easier to
navigate, we'd keep a single component in each file, but you'll forgive us this time for keeping it simple.</p>

<h3>Dependencies</h3>

<p>If you look at <code>todo.js</code> the first thing you'll notice is that all the code is wrapped in a call to the <code>steal</code> function:</p>

<pre><code class=" javascript">steal(<span class="string">'jquery/model/list'</span>,
      <span class="string">'jquery/controller'</span>,
      <span class="string">'jquery/view/ejs'</span>,
      <span class="string">'jquery/lang/json'</span>,
      <span class="string">'./todo.css'</span>,
      <span class="function"><span class="keyword">function</span><span class="params">($)</span>{</span>

...

});
</code></pre>

<p>In fact, this is true of every JavaScript file in a JavaScriptMVC application. This is how we state our dependencies
up-front, and tell the framework what libraries, plugins, stylesheets, etc. we need before we can begin. Typically,
the final argument to steal will be a function, which will be executed when all the other dependencies (and <em>their</em>
dependencies, and so on...) have been loaded and executed as well. No more worrying whether you forgot any <code>&lt;script&gt;</code>
tags, or whether you've got them in the right order!</p>

<p>For our TODO app, we can see that our script requires the <a href="#!jQuery.Model.List">$.Model.List</a> class (which itself requires
the <a href="#!jQuery.Model">$.Model</a> class, the <a href="#!jQuery.Controller">$.Controller</a> class, a jQuery JSON helper, and our application's
stylesheet.</p>

<h3>Model</h3>

<p>All models in JavaScriptMVC extend the <a href="#!jQuery.Model">$.Model</a> class, like so:</p>

<pre><code class=" javascript">$.Model(<span class="string">'Todo'</span>, { <span class="comment">/* static properties */</span> }, { <span class="comment">/* instance/prototype properties */</span> });
</code></pre>

<p>(If you need a quick refresher on how to use JVMC's classes, see <a href="#!jQuery.Class">$.Class</a>.)</p>

<p>Since we want our TODO list manager to function without a server (who said application domains require servers, anyway?),
we need some form of persistence in the browser. Sure, cookies are nice, but we're looking to the future, man -- so lets
take advantage of HTML5's LocalStorage!</p>

<pre><code class=" javascript">$.Model(<span class="string">'Todo'</span>,{
  <span class="comment">/**
   * Gets JSON data from localStorage.  Any changes that 
   * get made in cb get written back to localStorage.
   * 
   * This is unimportant for understanding JavaScriptMVC!
   */</span>
  localStore: <span class="function"><span class="keyword">function</span><span class="params">(cb)</span>{</span>
    <span class="keyword">var</span> name = <span class="keyword">this</span>.shortName,
      data = $.evalJSON( window.localStorage[name] || (window.localStorage[name] = <span class="string">"{}"</span>) ),
      res = cb.call(<span class="keyword">this</span>, data);
    <span class="keyword">if</span>(res !== <span class="literal">false</span>){
      window.localStorage[name] = $.toJSON(data);
    }
  },
</code></pre>

<p>Here, we've defined our <code>Todo</code> class with a static (shared across all instances), state-of-the-art HTML5 storage system
(don't worry too much about what this does). The <code>localStore</code> method accepts a function which it assumes is a callback.
Since HTML5 local storage is a JSON-store, that means we'll receive an array of <code>Todo</code> <em>properties</em> when our callback
fires. All of our CRUD operations will use this helper in order to persist <code>Todo</code> items in the system.</p>

<pre><code>  findAll: function(params, success){
    this.localStore(function(todos){
      var instances = [];
      for(var id in todos){
        instances.push( new this( todos<a href="#!id">id</a>) )
      }
      success &amp;&amp; success(instances)
    })
  },
</code></pre>

<p>Given our <code>localStorage</code> helper, we've now defined a finder method that returns all <code>Todos</code> that the application knows
about. Inside the callback, we just iterate over those objects, and create <code>Todo</code>s out of them. Simple!</p>

<blockquote>
  <p><em>Tip</em>: Don't let that <code>new this( ... )</code> trip you up. Since we're in the static (class) context, <code>this</code> simply refers to the
  <code>Todo</code> class itself. Writing <code>new Todo( ... )</code> would have the same effect, but this way our code won't break if we ever
  decide to rename the class to something else.</p>
</blockquote>

<p>The rest of the CRUD methods are similar enough.</p>

<h3>Lists</h3>

<p>One of the truly great features of JavaScriptMVC is the <a href="#!jQuery.Model.List">$.Model.List</a>. A Model.List gives us a way
to manage a collection of models as an aggregate, and (the cool part) be able to respond to and trigger events at the
collection level. For our present purposes, we'd like to have a list of <code>Todo</code> items that can tell us which ones have
been marked as completed:</p>

<pre><code class=" javascript">$.Model.List(<span class="string">'Todo.List'</span>,{
  <span class="comment">/**
   * Return a new Todo.List of only complete items
   */</span>
  completed : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.grep(<span class="function"><span class="keyword">function</span><span class="params">(item)</span>{</span>
      <span class="keyword">return</span> item.complete === <span class="literal">true</span>;
    })
  }
});
</code></pre>

<p>Keep an eye out for this below when we're implementing the controller.</p>

<h2>Controller</h2>

<p>Unlike models, controllers and views are inherently tied to the application's user interface, so before we dive into the
JavaScript code, let's take a quick look at the basic HTML structure of the application:</p>

<pre><code class=" javascript">&lt;div id=<span class="string">'todos'</span>&gt;
  &lt;h1&gt;Todos&lt;/h1&gt;
  &lt;input type=<span class="string">'text'</span> class=<span class="string">'create'</span> /&gt; 
  &lt;ul id=<span class="string">'list'</span>&gt;
  &lt;/ul&gt;
  &lt;div id=<span class="string">'todo-stats'</span>&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Not much to it, is there! We can see that we have one wrapper element -- make a note of that, because that's the element
we're eventually going to attach the controller to.</p>

<p>Inside that wrapper, we have the following items:</p>

<ul>
<li>A title ("Todos")</li>
<li>A text box where we're going to add new Todo items</li>
<li>A list where we'll see all current Todo items</li>
<li>Another container for "stats" where we'll show a count of what the user has selected, and give them a way to "finish"
items</li>
</ul>

<p>With that document structure in mind, let's look at the code:</p>

<pre><code class=" javascript">$.Controller(<span class="string">'Todos'</span>,{

  <span class="comment">// sets up the widget</span>
  init : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

    <span class="comment">// empties the create input element</span>
    <span class="keyword">this</span>.find(<span class="string">".create"</span>).val(<span class="string">""</span>)[<span class="number">0</span>].focus();

    <span class="comment">// fills this list of items (creates add events on the list)</span>
    <span class="keyword">this</span>.options.list.findAll();
  },
</code></pre>

<p>The <code>init</code> method is what will be called when we initialize the controller. The <code>find</code> method here is like <code>jQuery.find</code>
in that it searches for a selector underneath an element -- in this case, the element being managed by the controller. We
want to look up the <code>.create</code> selector (the text box we saw above), set its text value to the empty string, and then
cause the browser to "focus," or place the mouse cursor in the box.</p>

<p>The second statement is the interesting one: because <code>this.options</code> always refers to the properties that were passed in to
the controller upon initialization, we can see here that we are expecting to be initialized with a list -- a <code>Todo.List</code>
to be exact. Another great thing about <a href="#!jQuery.Model.List">$.Model.List</a>s is that they steal most of their default behavior
from the underlying model, so basically we've gotten a free implementation of <code>findAll</code>, simply because <code>Todo</code> has a
<code>findAll</code> method. Pretty nice!</p>

<p>We also saw that <a href="#!jQuery.Model.List">$.Model.List</a>s trigger their own events which we can listen on in. Keep an eye out
for that below.</p></div>
			<div id="disqus_thread"></div>
		</div>
	</div>
</div>
<div id="low">
	<a href="http://jupiterit.com">ï¿½ Jupiter IT - JavaScriptMVC Training and Support</a>
	<a class="api_links" href="http://javascriptmvc.com/docs/api.html#&amp;who=api"></a>
</div>
<script src="http://www.google-analytics.com/ga.js" type="text/javascript"></script>
<script type="text/javascript">
	GOOGLE_ANALYTICS_TRACKER_ID = "UA-xxxxxxxx-x";
</script>
<script type="text/javascript">
	DOCS_LOCATION = "docs/" //adds searchData to this
	JMVCDOC_TIMESTAMP = 263436055
</script>
<script type="text/javascript" src="../steal/steal.js?jmvcdoc">
</script>
	

</body>