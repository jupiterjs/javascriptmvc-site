C({"name": "q", "type": "attribute", "comment": "<p>\"\n        },</p>\n\n<pre><code>    contents: {\n        xml: /xml/,\n        html: /html/,\n        json: /json/\n    },\n\n    responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\"\n    },\n\n    // List of data converters\n    // 1) key format is \"source_type destination_type\" (a single space in-between)\n    // 2) the catchall symbol \"*\" can be used for source_type\n    converters: {\n\n        // Convert anything to text\n        \"* text\": window.String,\n\n        // Text to html (true = no transformation)\n        \"text html\": true,\n\n        // Evaluate text as a json expression\n        \"text json\": jQuery.parseJSON,\n\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n    }\n},\n\najaxPrefilter: addToPrefiltersOrTransports( prefilters ),\najaxTransport: addToPrefiltersOrTransports( transports ),\n\n// Main method\najax: function( url, options ) {\n\n    // If url is an object, simulate pre-1.5 signature\n    if ( typeof url === \"object\" ) {\n        options = url;\n        url = undefined;\n    }\n\n    // Force options to be an object\n    options = options || {};\n\n    var // Create the final options object\n        s = jQuery.ajaxSetup( {}, options ),\n        // Callbacks context\n        callbackContext = s.context || s,\n        // Context for global events\n        // It's the callbackContext if one was provided in the options\n        // and if it's a DOM node or a jQuery collection\n        globalEventContext = callbackContext !== s &amp;&amp;\n            ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?\n                    jQuery( callbackContext ) : jQuery.event,\n        // Deferreds\n        deferred = jQuery.Deferred(),\n        completeDeferred = jQuery._Deferred(),\n        // Status-dependent callbacks\n        statusCode = s.statusCode || {},\n        // ifModified key\n        ifModifiedKey,\n        // Headers (they are sent all at once)\n        requestHeaders = {},\n        requestHeadersNames = {},\n        // Response headers\n        responseHeadersString,\n        responseHeaders,\n        // transport\n        transport,\n        // timeout handle\n        timeoutTimer,\n        // Cross-domain detection vars\n        parts,\n        // The jqXHR state\n        state = 0,\n        // To know if global events are to be dispatched\n        fireGlobals,\n        // Loop variable\n        i,\n        // Fake xhr\n        jqXHR = {\n\n            readyState: 0,\n\n            // Caches the header\n            setRequestHeader: function( name, value ) {\n                if ( !state ) {\n                    var lname = name.toLowerCase();\n                    name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n                    requestHeaders[ name ] = value;\n                }\n                return this;\n            },\n\n            // Raw string\n            getAllResponseHeaders: function() {\n                return state === 2 ? responseHeadersString : null;\n            },\n\n            // Builds headers hashtable if needed\n            getResponseHeader: function( key ) {\n                var match;\n                if ( state === 2 ) {\n                    if ( !responseHeaders ) {\n                        responseHeaders = {};\n                        while( ( match = rheaders.exec( responseHeadersString ) ) ) {\n                            responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n                        }\n                    }\n                    match = responseHeaders[ key.toLowerCase() ];\n                }\n                return match === undefined ? null : match;\n            },\n\n            // Overrides response content-type header\n            overrideMimeType: function( type ) {\n                if ( !state ) {\n                    s.mimeType = type;\n                }\n                return this;\n            },\n\n            // Cancel the request\n            abort: function( statusText ) {\n                statusText = statusText || \"abort\";\n                if ( transport ) {\n                    transport.abort( statusText );\n                }\n                done( 0, statusText );\n                return this;\n            }\n        };\n\n    // Callback for when everything is done\n    // It is defined here because jslint complains if it is declared\n    // at the end of the function (which would be more logical and readable)\n    function done( status, statusText, responses, headers ) {\n\n        // Called once\n        if ( state === 2 ) {\n            return;\n        }\n\n        // State is \"done\" now\n        state = 2;\n\n        // Clear timeout if it exists\n        if ( timeoutTimer ) {\n            clearTimeout( timeoutTimer );\n        }\n\n        // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n        transport = undefined;\n\n        // Cache response headers\n        responseHeadersString = headers || \"\";\n\n        // Set readyState\n        jqXHR.readyState = status ? 4 : 0;\n\n        var isSuccess,\n            success,\n            error,\n            response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,\n            lastModified,\n            etag;\n\n        // If successful, handle type chaining\n        if ( status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304 ) {\n\n            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n            if ( s.ifModified ) {\n\n                if ( ( lastModified = jqXHR.getResponseHeader( \"Last-Modified\" ) ) ) {\n                    jQuery.lastModified[ ifModifiedKey ] = lastModified;\n                }\n                if ( ( etag = jqXHR.getResponseHeader( \"Etag\" ) ) ) {\n                    jQuery.etag[ ifModifiedKey ] = etag;\n                }\n            }\n\n            // If not modified\n            if ( status === 304 ) {\n\n                statusText = \"notmodified\";\n                isSuccess = true;\n\n            // If we have data\n            } else {\n\n                try {\n                    success = ajaxConvert( s, response );\n                    statusText = \"success\";\n                    isSuccess = true;\n                } catch(e) {\n                    // We have a parsererror\n                    statusText = \"parsererror\";\n                    error = e;\n                }\n            }\n        } else {\n            // We extract error from statusText\n            // then normalize statusText and status for non-aborts\n            error = statusText;\n            if( !statusText || status ) {\n                statusText = \"error\";\n                if ( status &lt; 0 ) {\n                    status = 0;\n                }\n            }\n        }\n\n        // Set data for the fake xhr object\n        jqXHR.status = status;\n        jqXHR.statusText = statusText;\n\n        // Success/Error\n        if ( isSuccess ) {\n            deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n        } else {\n            deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n        }\n\n        // Status-dependent callbacks\n        jqXHR.statusCode( statusCode );\n        statusCode = undefined;\n\n        if ( fireGlobals ) {\n            globalEventContext.trigger( \"ajax\" + ( isSuccess ? \"Success\" : \"Error\" ),\n                    [ jqXHR, s, isSuccess ? success : error ] );\n        }\n\n        // Complete\n        completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );\n\n        if ( fireGlobals ) {\n            globalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s] );\n            // Handle the global AJAX counter\n            if ( !( --jQuery.active ) ) {\n                jQuery.event.trigger( \"ajaxStop\" );\n            }\n        }\n    }\n\n    // Attach deferreds\n    deferred.promise( jqXHR );\n    jqXHR.success = jqXHR.done;\n    jqXHR.error = jqXHR.fail;\n    jqXHR.complete = completeDeferred.done;\n\n    // Status-dependent callbacks\n    jqXHR.statusCode = function( map ) {\n        if ( map ) {\n            var tmp;\n            if ( state &lt; 2 ) {\n                for( tmp in map ) {\n                    statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];\n                }\n            } else {\n                tmp = map[ jqXHR.status ];\n                jqXHR.then( tmp, tmp );\n            }\n        }\n        return this;\n    };\n\n    // Remove hash character (#7531: and string promotion)\n    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n    // We also use the url parameter if available\n    s.url = ( ( url || s.url ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n    // Extract dataTypes list\n    s.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().split( rspacesAjax );\n\n    // Determine if a cross-domain request is in order\n    if ( s.crossDomain == null ) {\n        parts = rurl.exec( s.url.toLowerCase() );\n        s.crossDomain = !!( parts &amp;&amp;\n            ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||\n                ( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n                    ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n        );\n    }\n\n    // Convert data if not already a string\n    if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== \"string\" ) {\n        s.data = jQuery.param( s.data, s.traditional );\n    }\n\n    // Apply prefilters\n    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n    // If request was aborted inside a prefiler, stop there\n    if ( state === 2 ) {\n        return false;\n    }\n\n    // We can fire global events as of now if asked to\n    fireGlobals = s.global;\n\n    // Uppercase the type\n    s.type = s.type.toUpperCase();\n\n    // Determine if request has content\n    s.hasContent = !rnoContent.test( s.type );\n\n    // Watch for a new set of requests\n    if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {\n        jQuery.event.trigger( \"ajaxStart\" );\n    }\n\n    // More options handling for requests with no content\n    if ( !s.hasContent ) {\n\n        // If data is available, append data to url\n        if ( s.data ) {\n            s.url += ( rquery.test( s.url ) ? \"&amp;\" : \"?\" ) + s.data;\n        }\n\n        // Get ifModifiedKey before adding the anti-cache parameter\n        ifModifiedKey = s.url;\n\n        // Add anti-cache in url if needed\n        if ( s.cache === false ) {\n\n            var ts = jQuery.now(),\n                // try replacing _= if it is there\n                ret = s.url.replace( rts, \"$1_=\" + ts );\n\n            // if nothing was replaced, add timestamp to the end\n            s.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? \"&amp;\" : \"?\" ) + \"_=\" + ts : \"\" );\n        }\n    }\n\n    // Set the correct header, if data is being sent\n    if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {\n        jqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n    }\n\n    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n    if ( s.ifModified ) {\n        ifModifiedKey = ifModifiedKey || s.url;\n        if ( jQuery.lastModified[ ifModifiedKey ] ) {\n            jqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ ifModifiedKey ] );\n        }\n        if ( jQuery.etag[ ifModifiedKey ] ) {\n            jqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ ifModifiedKey ] );\n        }\n    }\n\n    // Set the Accepts header for the server, depending on the dataType\n    jqXHR.setRequestHeader(\n        \"Accept\",\n        s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?\n            s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \n</code></pre>", "src": "../funcunit/browser/resources/jquery.js", "children": []})