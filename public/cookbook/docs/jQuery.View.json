C({"name": "jQuery.View", "type": "class", "comment": "<p>View provides a uniform interface for using templates with \njQuery. When template engines [jQuery.View.register register] \nthemselves, you are able to:</p>\n\n<ul>\n<li>Use views with jQuery extensions [jQuery.fn.after after], [jQuery.fn.append append],\n[jQuery.fn.before before], [jQuery.fn.html html], [jQuery.fn.prepend prepend],\n[jQuery.fn.replaceWith replaceWith], [jQuery.fn.text text].</li>\n<li>Template loading from html elements and external files.</li>\n<li>Synchronous and asynchronous template loading.</li>\n<li>[view.deferreds Deferred Rendering].</li>\n<li>Template caching.</li>\n<li>Bundling of processed templates in production builds.</li>\n<li>Hookup jquery plugins directly in the template.</li>\n</ul>\n\n<p>The [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.</p>\n\n<h2>Use</h2>\n\n<p>When using views, you're almost always wanting to insert the results \nof a rendered template into the page. jQuery.View overwrites the \njQuery modifiers so using a view is as easy as: </p>\n\n<pre><code>$(\"#foo\").html('mytemplate.ejs',{message: 'hello world'})\n</code></pre>\n\n<p>This code:</p>\n\n<ul>\n<li><p>Loads the template a 'mytemplate.ejs'. It might look like:\n<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code></p></li>\n<li><p>Renders it with {message: 'hello world'}, resulting in:\n<pre><code>&lt;div id='foo'>\"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code></p></li>\n<li><p>Inserts the result into the foo element. Foo might look like:\n<pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code></p></li>\n</ul>\n\n<h2>jQuery Modifiers</h2>\n\n<p>You can use a template with the following jQuery modifiers:</p>\n\n<table>\n<tr><td>[jQuery.fn.after after]</td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.append append] </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.before before] </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.html html] </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.prepend prepend] </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.replaceWith replaceWith] </td><td> <code>$('#bar').replaceWidth('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.text text] </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>\n</table>\n\n<p>You always have to pass a string and an object (or function) for the jQuery modifier \nto user a template.</p>\n\n<h2>Template Locations</h2>\n\n<p>View can load from script tags or from files. </p>\n\n<h2>From Script Tags</h2>\n\n<p>To load from a script tag, create a script tag with your template and an id like: </p>\n\n<pre><code>&lt;script type='text/ejs' id='recipes'>\n&lt;% for(var i=0; i &lt; recipes.length; i++){ %>\n  &lt;li>&lt;%=recipes[i].name %>&lt;/li>\n&lt;%} %>\n&lt;/script></code></pre>\n\n<p>Render with this template like: </p>\n\n<pre><code class='javascript'>$(\"#foo\").html('recipes',recipeData)</code></pre>\n\n<p>Notice we passed the id of the element we want to render.</p>\n\n<h2>From File</h2>\n\n<p>You can pass the path of a template file location like:</p>\n\n<pre><code>$(\"#foo\").html('templates/recipes.ejs',recipeData)\n</code></pre>\n\n<p>However, you typically want to make the template work from whatever page they \nare called from.  To do this, use // to look up templates from JMVC root:</p>\n\n<pre><code>$(\"#foo\").html('//app/views/recipes.ejs',recipeData)\n</code></pre>\n\n<p>Finally, the [jQuery.Controller.prototype.view controller/view] plugin can make looking\nup a thread (and adding helpers) even easier:</p>\n\n<pre><code>$(\"#foo\").html( this.view('recipes', recipeData) )\n</code></pre>\n\n<h2>Packaging Templates</h2>\n\n<p>If you're making heavy use of templates, you want to organize \nthem in files so they can be reused between pages and applications.</p>\n\n<p>But, this organization would come at a high price \nif the browser has to \nretrieve each template individually. The additional \nHTTP requests would slow down your app. </p>\n\n<p>Fortunately, [steal.static.views steal.views] can build templates \ninto your production files. You just have to point to the view file like: </p>\n\n<pre><code>steal.views('path/to/the/view.ejs');\n</code></pre>\n\n<h2>Asynchronous</h2>\n\n<p>By default, retrieving requests is done synchronously. This is \nfine because StealJS packages view templates with your JS download. </p>\n\n<p>However, some people might not be using StealJS or want to delay loading \ntemplates until necessary. If you have the need, you can \nprovide a callback paramter like: </p>\n\n<pre><code>$(\"#foo\").html('recipes',recipeData, function(result){\n  this.fadeIn()\n});\n</code></pre>\n\n<p>The callback function will be called with the result of the \nrendered template and 'this' will be set to the original jQuery object.</p>\n\n<h2>Deferreds (3.0.6)</h2>\n\n<p>If you pass deferreds to $.View or any of the jQuery \nmodifiers, the view will wait until all deferreds resolve before \nrendering the view.  This makes it a one-liner to make a request and \nuse the result to render a template. </p>\n\n<p>The following makes a request for todos in parallel with the \ntodos.ejs template.  Once todos and template have been loaded, it with\nrender the view with the todos.</p>\n\n<pre><code>$('#todos').html(\"todos.ejs\",Todo.findAll());\n</code></pre>\n\n<h2>Just Render Templates</h2>\n\n<p>Sometimes, you just want to get the result of a rendered \ntemplate without inserting it, you can do this with $.View: </p>\n\n<pre><code>var out = $.View('path/to/template.jaml',{});\n</code></pre>\n\n<h2>Preloading Templates</h2>\n\n<p>You can preload templates asynchronously like:</p>\n\n<pre><code>$.get('path/to/template.jaml',{},function(){},'view');\n</code></pre>\n\n<h2>Supported Template Engines</h2>\n\n<p>JavaScriptMVC comes with the following template languages:</p>\n\n<ul>\n<li><p>EmbeddedJS</p>\n\n<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre></li>\n<li><p>JAML</p>\n\n<pre><code>h2(data.message);</code></pre></li>\n<li><p>Micro</p>\n\n<pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre></li>\n<li><p>jQuery.Tmpl</p>\n\n<pre><code>&lt;h2>${message}&lt;/h2></code></pre></li>\n</ul>\n\n<p>The popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a> \ntemplate engine is supported in a 2nd party plugin.</p>\n\n<h2>Using other Template Engines</h2>\n\n<p>It's easy to integrate your favorite template into $.View and Steal.  Read \nhow in [jQuery.View.register].</p>", "parents": ["jquerymx"], "plugin": "jquery/view", "test": "jquery/view/qunit.html", "download": "dist/jquery.view.js", "construct": "<p>Looks up a template, processes it, caches it, then renders the template\nwith data and optional helpers.</p>\n\n<p>With [stealjs StealJS], views are typically bundled in the production build.\nThis makes it ok to use views synchronously like:</p>\n\n<pre><code class='javascript'>$.View(\"//myplugin/views/init.ejs\",{message: \"Hello World\"})</code></pre>\n\n<p>If you aren't using StealJS, it's best to use views asynchronously like:</p>\n\n<pre><code class='javascript'>$.View(\"//myplugin/views/init.ejs\",\n       {message: \"Hello World\"}, function(result){\n  // do something with result\n})</code></pre>", "ret": {"description": "<p>The rendered result of the view or if deferreds are passed, a deferred that will contain\nthe rendered result of the view.</p>", "type": "String"}, "params": {"view": {"order": 0, "description": "<p>The url or id of an element to use as the template's source.</p>", "name": "view", "type": "String", "optional": false}, "data": {"order": 1, "description": "<p>The data to be passed to the view.</p>", "name": "data", "type": "Object", "optional": false}, "helpers": {"order": 2, "description": "<p>Optional helper functions the view might use. Not all\ntemplates support helpers.</p>", "name": "helpers", "type": "Object", "optional": true}, "callback": {"order": 3, "description": "<p>Optional callback function.  If present, the template is \nretrieved asynchronously.  This is a good idea if you aren't compressing the templates\ninto your view.</p>", "name": "callback", "type": "Object", "optional": true}}, "src": "../jquery/view/view.js", "children": ["jQuery.View.hookups", "jQuery.View.hookup", "jQuery.View.cached", "jQuery.View.cache", "jQuery.View.register", "jQuery.View.ext", "jQuery.View.registerScript", "jQuery.View.preload", "jQuery.fn.prepend", "jQuery.fn.append", "jQuery.fn.after", "jQuery.fn.before", "jQuery.fn.text", "jQuery.fn.html", "jQuery.fn.replaceWith"]})