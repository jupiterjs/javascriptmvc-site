c({"name": "can.Model.static.findOne", "type": "function", "parents": ["can.Model.static"], "comment": "<p><code>findOne( params, success(instance), error(xhr) ) -&gt; Deferred</code> is used to retrieve a model \ninstance from the server. Before you can use <code>findOne</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : \"/recipes/{id}.json\"\n},{});\n</code></pre>\n\n<p>If <code>findOne</code> is called like:</p>\n\n<pre><code>Recipe.findOne({id: 57});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>{\"id\" : 57, \"name\": \"Ice Water\"}\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement <code>findOne</code> with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : {\n    url: \"/recipes/{id}.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findOne</code> is passed <strong>params</strong> to specify\nthe instance retrieved from the server and it should return a\ndeferred that resolves to the model data.  Also notice that you now need to\nbuild the URL manually. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : function(params){\n    return $.ajax({\n      url: '/recipes/' + params.id,\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findOne</code>, you can use it to retrieve an instance of the model\nlike:</p>\n\n<pre><code>Recipe.findOne({id: 57}, function(recipe){\n     recipe.attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n     // called if an error\n}) //-&gt; Deferred\n</code></pre>\n\n<p>The following API details the use of <code>findOne</code>.</p>", "params": {"params": {"order": 0, "description": "<p>data to specify the instance. </p>\n\n<pre><code>Recipe.findAll({id: 20})\n</code></pre>", "name": "params", "type": "Object", "optional": false}, "success(item)": {"order": 1, "description": "<p>called with a model \ninstance.  The model isntance is created from the Deferred's resolved data.</p>\n\n<pre><code>Recipe.findOne({id: 20}, function(recipe){\n  recipe.constructor //-&gt; Recipe\n})\n</code></pre>", "name": "success(item)", "type": "Function", "optional": true}, "error(xhr)": {"order": 2, "description": "<p><code>error</code> is called if the Deferred is rejected with the\nxhr handler.</p>", "name": "error(xhr)", "type": "Function", "optional": false}}, "ret": {"description": "<p>a [can.Deferred Deferred] that <strong>resolves</strong> to\nthe model instance and <strong>rejects</strong> to the XHR object.</p>\n\n<pre><code>Recipe.findOne({id: 20})\n      .then(function(recipe){\n\n      }, function(xhr){\n\n      })\n</code></pre>", "type": "Deferred"}, "src": {"query": "", "fragment": "", "path": "can/model/model.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 446, "children": []})