c({"name": "can.view.modifiers", "children": ["jQuery.fn.jQuery.fn.prepend", "jQuery.fn.jQuery.fn.append", "jQuery.fn.jQuery.fn.after", "jQuery.fn.jQuery.fn.before", "jQuery.fn.jQuery.fn.text", "jQuery.fn.jQuery.fn.html", "jQuery.fn.jQuery.fn.replaceWith"], "type": "page", "comment": "<p>The can/view/modifiers plugin extends the jQuery view modifiers</p>\n\n<ul>\n<li>[can.prototype.jQuery.fn.after .after()]</li>\n<li>[can.prototype.jQuery.fn.append .append()]</li>\n<li>[can.prototype.jQuery.fn.before .before()]</li>\n<li>[can.prototype.jQuery.fn.html .html()]</li>\n<li>[can.prototype.jQuery.fn.prepend .prepend()]</li>\n<li>[can.prototype.jQuery.fn.replaceWith .replaceWith()]</li>\n<li>[can.prototype.jQuery.fn.text .text()]</li>\n</ul>\n\n<p>to render a [can.view]. When rendering a view you call the view modifier the same way\nas can.view with the view name or id as the first, the data as the second and the optional\nsuccess callback (to load the view asynchronously) as the third parameter.\nFor example, you can render a template from <em>todo/todos.ejs</em> looking like this:</p>\n\n<pre><code>&lt;% for(var i = 0; i &lt; this.length; i++ ){ %&gt;\n  &lt;li&gt;&lt;%= this[i].name %&gt;&lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>By calling the [can.prototype.jQuery.fn.html html] modifier on the <code>#todos</code> element like this:</p>\n\n<pre><code>can.$('#todos').html('todo/todos.ejs', [\n    { name : 'First Todo' },\n    { name : 'Second Todo' }\n]);\n</code></pre>\n\n<p><strong>Note:</strong> You always have to provide the data (second) argument to render a view, otherwise the standard jQuery\nmodifier will be used. If you have no data to render pass an empty object:</p>\n\n<pre><code>$('#todos').html('todo/todos.ejs', {});\n// Render todo/todos.ejs wit no data\n</code></pre>\n\n<h2>Deferreds</h2>\n\n<p>Additionally it is also possible to pass a [can.Deferred] as a single parameter to any view modifier. Once\nthe deferred resolves the result will be rendered using that modifier. This can be used to easily request\nand render static content. The following example inserts the content of <em>content/info.html</em> after the <code>#todos</code> element:</p>\n\n<pre><code>can.$('#todos').after(can.ajax({\n    url : 'content/info.html'\n}));\n</code></pre>", "parents": ["can.view"], "plugin": "can/view/modifiers", "test": "can/view/modifiers/qunit.html", "src": "can/view/modifiers/modifiers.md"})