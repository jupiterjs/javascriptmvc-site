c({"name": "can.Construct.proxy", "type": "page", "comment": "<p><code>can.Construct.prototype.proxy( funcName, [args...] )</code> takes a \nfunction name and returns a new function that\nwill call the original function with the same <code>this</code> \nfrom which it was created. <code>proxy</code> is useful \nfor creating callback functions that have 'this' \nset correctly.</p>\n\n<p>The following example increments a <code>Counter</code>'s <code>count</code>\nevery second:</p>\n\n<pre><code>Counter = can.Construct({\n  init : function(){\n    this.count = 0;\n    setTimeout( this.proxy(function(){\n      this.count++;\n    }), 1000 );\n  }\n})\nvar counter = new Counter();\n// later check count\nsetTimeout(function(){\n  console.log(counter.count)\n},5000)\n</code></pre>\n\n<p><code>proxy</code> also accepts a method name like <code>this.proxy('methodName')</code>, allowing \nthe previous example to work like:</p>\n\n<pre><code>Counter = can.Construct({\n  init : function(){\n    this.count = 0;\n    setTimeout( this.proxy('increment'), 1000);\n  },\n  increment : function(){\n    this.count++;\n  }\n})\n</code></pre>\n\n<h2>Currying Arguments</h2>\n\n<p>Pass additional arguments to <code>proxy</code> and it will \nfill in arguments on the returning function.  When invoked,\nthe additional arguments will appear first in the methods\nparameters followed by the callback's arguments.</p>\n\n<p>The <code>Counter</code> constructor accepts a <code>by</code> argument which is used\nto increment the count by the <code>by</code> amount specified.  </p>\n\n<pre><code>Counter = can.Construct({\n  init : function( by ) {\n    this.count = 0;\n    setTimeout( this.proxy('increment', by), 1000);\n  },\n  increment : function( by ) {\n    this.count += by;\n  }\n})\n\n// create a counter that increments by 10\nnew Counter(10)\n</code></pre>\n\n<h2>Piping Functions</h2>\n\n<p><code>proxy</code> can take an array of functions to call as \nthe first argument.  When the returned callback function\nis called each function in the array is passed the return \nvalue of the prior function.  This is often used\nto eliminate currying callback functions.</p>\n\n<p>The <code>Counter</code> accepts a callback that will be called with \nthe count every second.</p>\n\n<pre><code>Counter = can.Construct({\n  init : function( by , callback) {\n    this.count = 0;\n    setTimeout( this.proxy(['increment', callback], by), 1000);\n  },\n  increment : function( by ) {\n    this.count += by;\n    // return the arguments passed to the next function\n    return [this.count]\n  }\n})\n\nnew Counter(10, function(count){\n  console.log(count);\n})\n</code></pre>\n\n<h2><code>proxy</code> on Constructors</h2>\n\n<p><code>proxy</code> is also available on constructor functions.  Example:</p>\n\n<pre><code>Counter = can.Construct({\n  start : function(){\n    this.count = 0;\n    setTimeout( this.proxy('increment'), 1000);\n  },\n  increment : function(){\n    this.count++;\n  }\n},{});\n\nCounter.start();\n</code></pre>", "parents": ["can.Construct"], "plugin": "can/construct/proxy", "test": "can/construct/proxy/qunit.html", "download": "http://donejs.com/can/dist/can.construct.proxy.js", "src": "can/construct/proxy/proxy.md", "children": []})