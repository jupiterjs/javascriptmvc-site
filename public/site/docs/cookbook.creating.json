c({"name": "cookbook.creating", "type": "page", "comment": "<p>We're going to create a basic cookbook application that\nlets us create, and delete recipes. It will look like:</p>\n\n<p><img class='image_tag' src='tutorials/getstarted/Cookbook.png' />\n</br>\nWe'll use JavaScriptMVC's [steal.generate generator scripts] to\nassist in setting up your application's\nfiles and folders. They save time creating boilerplate\njs, html, and css files.</p>\n\n<h2>Generating an Application</h2>\n\n<p>To create your application, open a console window and \nnavigate to your [rootfolder root folder], and run:</p>\n\n<pre><code>&gt; ./js jmvc/generate/app cookbook\n</code></pre>\n\n<p>This script creates an application folder and\nfiles. Here's what each file does:</p>\n\n<pre><code>cookbook/                // folder for your app\n  cookbook.less          // less for your app\n  index.html             // a page for your app\n  cookbook.js            // app file, loads other files\n  test.html              // app's test page\n  cookbook_test.js       // app's tests\n  models/                // model &amp; data layers\n    fixtures/            // simulated Ajax responses\n  scripts/               // command line scripts\n    build.html           // html for build script\n    build.js             // build script\n    clean.js             // code cleaning / linting\n    crawl.js             // generate search content\n    docs.js              // create documentation\n</code></pre>\n\n<p>We'll use index.html for our application. If \nyou need to make another page for your app you \ncan generate it:</p>\n\n<pre><code class='text'>> ./js jmvc/generate/page cookbook dev.html\nGenerating ... dev.html</code></pre>\n\n<p>Or you add the steal script to an existing page \npage followed by <code>?cookbook</code> like:</p>\n\n<pre><code>&lt;script type='text/javascript'\n        src='../path/to/steal/steal.js?cookbook'&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>If you open [//cookbook/index.html], you'll see a\nJavaScriptMVC welcome screen.  </p>\n\n<p><img class='image_tag' src='tutorials/getstarted/Welcome.png' />\n<br/>Open <code>cookbook/index.html</code> and you will find:</p>\n\n<pre><code>&lt;script src='../steal/steal.js?cookbook'&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>This line loads [steal] and tells steal to \nload <code>cookbook/cookbook.js</code>. <code>cookbook/cookbook.js</code> is\nyour application file.  Open it and you will find:</p>\n\n<pre><code>steal(\n    './cookbook.less',          \n    './models/fixtures/fixtures.js',    \n    function(){                 \n\n})\n</code></pre>\n\n<p>The application file loads and configures your applications resources.  Currently,\nit's loading the app's less file, fixtures (there are no fixtures yet).</p>\n\n<p>Now it's time to make some widgets, models, and fixtures that allow us to create and delete\nrecipes!  </p>\n\n<h2>Scaffolding Recipes</h2>\n\n<p>We'll use the scaffold generator to quickly create:</p>\n\n<ul>\n<li>A Recipe model for CRUDing recipes on the server</li>\n<li>A Fixture for simulating a recipe service</li>\n<li>A widget for creating recipes</li>\n<li>A widget for listing and deleting recipes</li>\n</ul>\n\n<p>To scaffold recipes run the following in the command-line console:</p>\n\n<pre><code>&gt; ./js jmvc/generate/scaffold cookbook/models/recipe\n</code></pre>\n\n<p>Here's what each part does:</p>\n\n<p><strong>recipe.js</strong></p>\n\n<p>Creates a recipe [can.Model model] that is used\nto create, retrieve, updated, and delete \nrecipes on the server.</p>\n\n<p><strong>recipe_test.js</strong></p>\n\n<p>Tests the recipe model.</p>\n\n<p><strong>fixtures.js</strong></p>\n\n<p>The generator added code to simulate the Recipe Model's Ajax\nrequests (You might not have a Recipe service).</p>\n\n<p><strong>recipe/create</strong></p>\n\n<p>This folder contains the code, demo page, and tests for a\nwidget that creates Recipes.</p>\n\n<p><strong>recipe/list</strong></p>\n\n<p>This folder contains the code, demo page, and tests for a\nwidget that lists recipes.</p>\n\n<p><strong>(steal added)</strong></p>\n\n<p>\"(steal added)\" means the generator is \nadding a steal call to load\na generated file for you.  For example, \n<code>cookbook/cookbook.js</code> now steals <code>'cookbook/recipe/create'</code> and <code>'cookbook/recipe/list'</code>.</p>\n\n<h2>Page Setup</h2>\n\n<p>After the generator runs, your application file (<code>cookbook.js</code>)\nlooks like:</p>\n\n<pre><code>steal(\n    'cookbook/recipe/create',\n    'cookbook/recipe/list',\n    './cookbook.less',\n    './models/fixtures/fixtures.js',\n    function(RecipeCreate, RecipeList){\n\n    new RecipeList('#recipes');\n    new RecipeCreate('#create');\n})\n</code></pre>\n\n<p>You'll notice that it now loads <code>cookbook/recipe/create</code>\nand <code>cookbook/recipe/list</code> and then tries to add these widgets to the\n<code>#recipes</code> and <code>#create</code> elements.  </p>\n\n<p>However, <code>#recipes</code> and <code>#create</code> elements did not \nexist! Fortunately, the generator also added their HTML to <code>index.html</code> so that \nit includes:</p>\n\n<h2>Run Cookbook</h2>\n\n<p>That's it. You've created a simple Cookbook \napplication. Open cookbook/cookbook.html in a browser. </p>\n\n<p><img class='image_tag' src='tutorials/getstarted/Cookbook.png' /></p>\n\n<div style='background-color: #dddddd;  margin: 20px 0px;padding: 20px'>\n<p>\n<b style='color:red'>NOTICE:</b> \nIf you are having problems and \nusing Chrome from the filesystem, it's because Chrome has an\n[http://code.google.com/p/chromium/issues/detail?id=47416 insanely restrictive AJAX policies on the filesystem].\n</p>\n<p>\nEssentially, Chrome does not allow AJAX requests to\nfiles outside the html page's folder.  JavaScriptMVC\norganizes your files into separate folders.\n</p>\n<p>\nTo fix this, just run JavaScriptMVC from a web server.\nOr, you can use another browser.  Or you can add\n`--allow-file-access-from-files` to Chrome's start script.\n</p>\n<p>\nIf you're annoyed like we are, \n[http://code.google.com/p/chromium/issues/detail?id=47416 star the issue]\nand let \ngoogle know you'd like Chrome to work on the filesystem!\n</p>\n</div>\n\n<p>Continue to [cookbook.testing Testing Cookbook] or continue to read how\nthis code works.</p>\n\n<h2>How it Works</h2>\n\n<p>The Cookbook application can be broken into 5 parts:</p>\n\n<ul>\n<li>The Recipe model</li>\n<li>The recipes fixture</li>\n<li>The RecipeCreate control</li>\n<li>The RecipeList control</li>\n<li>The cookbook application that puts it all together</li>\n</ul>\n\n<h3>The Recipe Model and Fixture</h3>\n\n<p><code>cookbook/models/recipe.js</code> looks like:</p>\n\n<pre><code>steal('can', function (can) {\n\n    return can.Model(\n    {\n        findAll : \"GET /recipes\",\n        findOne : \"GET /recipes/{id}\",\n        create : \"POST /recipes\",\n        update : \"PUT /recipes/{id}\",\n        destroy : \"DELETE /recipes/{id}\"\n    },\n    {});\n});\n</code></pre>\n\n<p>This loads CanJS's core, which includes [can.Model], and uses it to create a \nconstructor function that lets us\ncreate, retrieve, update, and delete models programmatically like:</p>\n\n<p><strong>create</strong></p>\n\n<pre><code>// create a recipe instance\nvar recipe = new Recipe({\n  name: 'Hot Dog',\n  description: 'nuke dog, put in bun'\n})\n\n// call save to create on the server\nrecipe.save()\n</code></pre>\n\n<p><strong>retrieve</strong></p>\n\n<pre><code>// get recipes from the server\nRecipe.findAll({}, function(recipes){\n  // do something with recipes\n})\n</code></pre>\n\n<p><strong>update</strong></p>\n\n<pre><code>// update the properties of a created recipe\nrecipe.attr({\n  name: 'Bratwurst',\n  description: 'nuke bratwurst, put in bun'\n});\n\n// call save to send updates to the server\nrecipe.save()\n</code></pre>\n\n<p><strong>delete</strong></p>\n\n<pre><code>// call destroy\nrecipe.destroy()\n</code></pre>\n\n<p>Of course, we don't have a server to make requests to. This is\nwhere fixtures come in.</p>\n\n<h3>The Recipe Fixture</h3>\n\n<p>[can.fixture Fixtures] intercept Ajax requests and\nsimulate the response. They enable\nyou to start work on the front end without a ready server.</p>\n\n<p>Open <code>cookbook/models/fixtures/fixtures.js</code> and you will this:</p>\n\n<pre><code>steal(\"can/util/fixture\", function(fixture) {\n\n    var store = fixture.store(5, function(i){\n        return {\n            name: \"recipe \"+i,\n            description: \"recipe \" + i\n        }\n    });\n\n    fixture({\n        'GET /recipes' : store.findAll,\n        'GET /recipes/{id}' : store.findOne,\n        'POST /recipes' : store.create,\n        'PUT /recipes/{id}' : store.update,\n        'DELETE /recipes/{id}' : store.destroy\n    });\n\n    return store;\n});\n</code></pre>\n\n<p>The scaffold generator added this to simulate a server \nwith 5 recipes.  Read more about how this works on\n[can.fixture.store store's documentation page].</p>\n\n<h3>The RecipeCreate control</h3>\n\n<p>Open <code>cookbook/recipe/create/create.html</code> in your \nbrowser.  This page demos the RecipeCreate control and\nlets you create recipes.  It lets us work on a control\nindependent of the rest of the application.</p>\n\n<p>Open <code>cookbook/recipe/create/create.js</code> to find:</p>\n\n<pre><code>steal('can', \n    'cookbook/models/recipe.js',\n    './init.ejs', \n    'jquery/dom/form_params',\n    function (can, Recipe, initView) {\n\n    return can.Control(\n    /** @Prototype */\n    {\n        init: function () {\n            this.element.html(initEJS());\n        },\n        submit: function (el, ev) {\n            ev.preventDefault();\n            el.find('[type=submit]').val('Creating...');\n\n            new Recipe(el.formParams()).save(function() {\n                el.find('[type=submit]').val('Create');\n                el[0].reset()\n            });\n        }\n    });\n});\n</code></pre>\n\n<p>This code uses [steal] to load dependencies and then creates and returns \na control constructor function.  In <code>cookbook/cookbook.js</code> that \ncontrol constructor function is aliased as RecipeCreate.  A new instance\nis created on the <code>#create</code> element as follows:</p>\n\n<pre><code>new RecipeCreate('#create')\n</code></pre>\n\n<p>When a control instance is created, the control's <code>init</code>\nmethod is called and runs </p>\n\n<pre><code>this.element.html(initEJS());\n</code></pre>\n\n<p><code>initEJS</code> is a [can.view.ejs renderer] function that renders\nthe template at <code>cookbook/recipe/create/init.ejs</code> into \na documentFragment. That document fragment is set as the control's inner html\nusing jQuery's [http://api.jquery.com/html/ html] method.</p>\n\n<p>When a control instance is created, it also binds event handlers on the\ncontrol's element.  In this case, it listens for \"submit\" events on the element.</p>\n\n<p>When a submit event happens, it updates the submit button's text, then creates\na new recipe.</p>\n\n<h3>The RecipeList control</h3>\n\n<p>Open <code>cookbook/recipe/list/list.html</code> in your \nbrowser.  This page demos the RecipeList control. It loads\nRecipes from the server, lets you delete recipes, and it also \nlistens for recipes being created and adds them to the list.</p>\n\n<p>Open <code>cookbook/recipe/list/list.js</code> to\nsee the control's code:</p>\n\n<pre><code>steal('can',\n    './init.ejs',\n    'cookbook/models/recipe.js',\n    function (can, initEJS, Recipe) {\n\n    return can.Control(\n    /** @Static */\n    {\n        defaults : {\n            Recipe: Recipe\n        }\n    },\n    /** @Prototype */\n    {\n        init: function () {\n            this.list = new Recipe.List();\n            this.element.html(initEJS(this.list));\n            this.list.replace(Recipe.findAll());\n        },\n        '.destroy click': function (el) {\n            if (confirm(\"Are you sure you want to destroy?\")) {\n                el.closest('.recipe').data('recipe').destroy();\n            }\n        },\n        \"{Recipe} created\": function (Model, ev, instance) {\n            this.list.push(instance);\n        }\n    });\n});\n</code></pre>\n\n<p>In <code>cookbook/cookbook.js</code>, when a <code>new RecipeList</code> is created, <code>init</code> is \ncalled. <code>init</code> first creates an empty [can.Model.List]:</p>\n\n<pre><code>this.list = new Recipe.List();\n</code></pre>\n\n<p>Then it renders <code>cookbook/recipe/list/init.ejs</code> and sets the result as\nthe inner html of the <code>controls</code> element:</p>\n\n<pre><code>this.element.html(initEJS(this.list));\n</code></pre>\n\n<p><code>init.ejs</code> looks like:</p>\n\n<pre><code>&lt;% this.each(function(current) { %&gt;\n  &lt;li class=\"recipe\" &lt;%= (el) -&gt; el.data('recipe', current) %&gt;&gt;\n  &lt;h3&gt;\n    &lt;%= current.attr('name') %&gt;\n    &lt;a href='javascript://' class='destroy'&gt;X&lt;/a&gt;\n  &lt;/h3&gt;\n  &lt;p&gt;&lt;%= current.attr('description') %&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<p>In the template, <code>this</code> is <code>this.list</code>. <code>this.list</code> is initially empty so\nthe inner html of <code>this.element</code> is empty. The <a href=\"items\">can.Observe.List::replace list.replace</a>\nmethod replaces the contents of the list with <code>items</code>.  If <code>items</code> is a\n[can.deferred deferred], it replaces the contents of the list with the\nresolved value of the deferred.</p>\n\n<p>The following replaces the items in <code>this.list</code> with <code>Recipes</code> from the server:</p>\n\n<pre><code>this.list.replace(Recipe.findAll());\n</code></pre>\n\n<p>Once the list is updated, the page is automatically updated \nwith live-binding. <code>init.ejs</code> iterates through the recipes. For each\nrecipe, it creates an LI element and renders <code>name</code> and <code>description</code>.</p>\n\n<p>Notice that the view adds each recipe instance to its LI element's data with:</p>\n\n<pre><code>&lt;%= (el) -&gt; el.data('recipe', current) %&gt;\n</code></pre>\n\n<p><strong>Destroying Recipes</strong></p>\n\n<p>Each recipe has a destroy link.  When it is clicked, the list's\n<code>'.destroy click'</code> method is called:</p>\n\n<pre><code>'.destroy click': function (el) {\n    if (confirm(\"Are you sure you want to destroy?\")) {\n        el.closest('.recipe').data('recipe').destroy();\n    }\n}\n</code></pre>\n\n<p>This method checks if you want to destroy the recipe.  If you do,\nit finds the parent 'recipe' element and gets back the recipe instance that's\nin jQuery.data. It then calls [can.Model.prototype.destroy model's destroy] method.</p>\n\n<p>When a model is destroyed, all occurrences will be removed from any list. Due to live binding\nthe recipe on the page will be removed automatically.</p>\n\n<p><strong>Creating Recipes</strong></p>\n\n<p>When a recipe is created, a \"created\" event is triggered.  The List control listens for this\nwith:</p>\n\n<pre><code>\"{Recipe} created\" : function(Recipe, ev, recipe){\n  this.list.push(recipe);\n}\n</code></pre>\n\n<p>When a recipe is created, we just add it to the list we are currently displaying.\nThanks to live binding the list will show the new recipe.</p>\n\n<h3>Putting it all Together</h3>\n\n<p>The cookbook application loads both of these widgets and adds them to the page.\nWhen RecipeCreate creates a Recipe, it creates a 'created' event which\nRecipeList listens for and adds that newly created recipe to its list\nof recipes.</p>\n\n<p>It's useful to notice that <code>RecipeCreate</code> and <code>RecipeList</code> operate independently of\neach other.</p>\n\n<p>Continue to [cookbook.testing Testing Cookbook].</p>", "title": "Creating Cookbook", "parents": ["getstarted"], "order": 0, "src": "tutorials/getstarted/creating.md", "children": []})