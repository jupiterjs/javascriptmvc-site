c({"name": "jQuery.Drag.prototype.position", "params": {"newOffsetv": {"description": "<p>the new [$.Drag::location] of the element.</p>", "type": "jQuery.Vector", "optional": false, "order": 0, "name": "newOffsetv"}}, "ret": {"type": "undefined", "description": ""}, "type": "function", "parents": ["jQuery.Drag.prototype"], "comment": "<p><code>drag.position( newOffsetVector )</code> sets the position of the movingElement.  This is overwritten by\nthe [$.Drag::scrolls], [$.Drag::limit] and [$.Drag::step] plugins \nto make sure the moving element scrolls some element\nor stays within some boundary.  This function is exposed and documented so you could do the same.</p>\n\n<p>The following approximates how step does it:</p>\n\n<pre><code>var oldPosition = $.Drag.prototype.position;\n$.Drag.prototype.position = function( offsetPositionv ) {\n  if(this._step){\n    // change offsetPositionv to be on the step value\n  }\n\n  oldPosition.call(this, offsetPosition)\n}\n</code></pre>", "src": {"query": "", "fragment": "", "path": "jquery/event/drag/drag.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 334, "children": []})