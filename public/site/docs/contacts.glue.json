c({"name": "contacts.glue", "type": "page", "comment": "<p>Now that we have learned how to create dumb, lonely, replaceable widgets, we need to glue them together into a smart app.</p>\n\n<h2>Changes in State</h2>\n\n<p>Events are significant changes in state, and EOA is a pattern that detects and consumes these changes in state.  EOA is an elegant way to tie decoupled modules together.</p>\n\n<h3>Cons of Callback Architecture</h3>\n\n<p>Traditionally widgets accept callbacks.  </p>\n\n<pre><code>$('div').modal({\n    closeCallback: windowClosed,\n    showCallback: windowOpened\n});\n</code></pre>\n\n<p>This type of architecture in not desirable for many reasons:</p>\n\n<ul>\n<li><p>The widget should be as dumb as possible.  When you pass a callback your widget becomes coupled to its parent widget because it becomes aware of the context in which its used.</p></li>\n<li><p>When you pass callbacks, only one widget can provide that callback.  It creates a 1-to-1 architecture, which limits the scalability of the application.</p></li>\n<li><p>Callbacks clutter the API and make it difficult for new developers to learn.</p></li>\n</ul>\n\n<h3>Event Oriented Architecture</h3>\n\n<p>Rather than using callbacks, the contacts application uses EOA.  One good example is how the grid is filtered from a user clicking an item in a list.</p>\n\n<p>As items are clicked in the list, it triggers an \"activate\" event, including the selected rowâ€™s model instance in the event.  </p>\n\n<pre><code>el.trigger(\"activate\", el.model());\n</code></pre>\n\n<p><em>Pro Tip:  Because we bound [jquery.fn.model instances of models using EJS] as shown below, in our controller code we can call .model() on the element that was bound to retrieve the model as shown above.</em></p>\n\n<pre><code>&lt;% for(var i =0 ; i &lt; items.length;i ++){ %&gt;\n      &lt;li &lt;%= items[i]%&gt; &gt;\n</code></pre>\n\n<p>The contacts widget then observes this state change using event delegation and updates the grid parameters.</p>\n\n<pre><code>\"#category .list_wrapper activate\": function(el, ev, item){\n    this.params.attr(\"categoryId\", item.id);\n}\n</code></pre>\n\n<p>The contacts widget listens for events high in the DOM, so it can capture any events triggered by child widgets.</p>\n\n<p><img class='image_tag' src='tutorials/images/eoa_diagram1.jpg' /></p>\n\n<p>Grid parameters are a JavaScriptMVC Model instance, used to define common data attributes like limit, offset, and count.  The JavascriptMVC Model implements an observer pattern. As changes are made to attributes, widgets can listen for the <em>updated</em> event and react accordingly.</p>\n\n<p>In the sample code above we call [jquery.model.prototype.attr attr] on this model instance to update the parameters.  The grid is listening for changes in the attributes.  Above, when activate is triggered, <em>categoryId</em> is changed.  The grid observes this change and executes an AJAX request to get data for the current parameter set. </p>\n\n<pre><code>\"{params} updated.attr\" : function(params, ev, attr, val){\n    if(attr !== 'count'){\n        //want to throttle for rapid updates\n        clearTimeout(this.newRequestTimer,100)\n        this.newRequestTimer = setTimeout(this.callback('newRequest', attr, val))\n    }\n},\n\nnewRequest : function(attr, val){\n    var clear = true; \n    if(!this.options.newPageClears &amp;&amp; attr == \"offset\"){ // if offset changes and we have newPageClears false\n        clear = false;\n    } \n    this.options.model.findAll(this.options.params.attrs(), this.callback('list', clear))\n}\n</code></pre>\n\n<p><img class='image_tag' src='tutorials/images/eoa_diagram2.jpg' /></p>\n\n<h2>Changes in Data</h2>\n\n<p>[jquery.model.events Model events] are events that are fired when CRUD operations (create/update/delete) occur on a model instance.  Widgets can bind to these events to automatically update when data changes.</p>\n\n<h3>Cons of Custom Events</h3>\n\n<p>A common widget communication pattern is triggering custom events when actions are completed.  For example, when a user clicks \"next page\" in a pagination widget, the paginator could trigger \"nextPage\" and the grid could listen and reload with new data.  This is also not desirable because:</p>\n\n<ul>\n<li><p>The widget should be as dumb as possible.  If a widget is listening to custom events from child widgets, you are coupling it to the parent widget.  We don't want the grid widget depending on a specific \"nextPage\" event from the paginator, making the paginator not easily replaceable.</p></li>\n<li><p>In some cases, the same state needs to be represented across multiple widgets. The grid, paginator, and possibly other widgets need to know about the current pagination data.  Rather than complicate the design by adding unnecessary layers, it makes more sense to maintain this state once (in the model), and let widgets listen to changes in that state.</p></li>\n</ul>\n\n<h3>Listening to Model Events</h3>\n\n<p>The List widget provides a good example of binding directly to model updates.</p>\n\n<pre><code>\"{model} updated\" : function(model, ev, item){\n    var el = item.elements(this.element).html(this.options.show, item);\n    if(this.options.updated){\n        this.options.updated(this.element, el, item)\n    }\n}\n</code></pre>\n\n<p>As model changes are made, such as an update to a contact's name, we listen for these changes in the List and update the UI accordingly using [jquery.model.events model events].</p>\n\n<h2>Wrap-up</h2>\n\n<p>In this article, we explored:</p>\n\n<ul>\n<li>The layers of the contacts application</li>\n<li>How to structure your application into modules, optimizing for widget reuse</li>\n<li>Designing widgets that are modular, testable, and have easy to use APIs</li>\n<li>How to glue your widgets together using event oriented architecture</li>\n</ul>\n\n<p>If you're interested in other examples, check out the other [examples application examples].</p>", "title": "Gluing Modules Together", "parents": ["contacts"], "order": 2, "src": "tutorials/examples/contacts/glue.md", "children": []})