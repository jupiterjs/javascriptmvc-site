c({"name": "can.Construct.prototype.setup", "type": "function", "parents": ["can.Construct.prototype"], "comment": "<p>If a prototype <code>setup</code> method is provided, it is called when a new \ninstance is created.  It is passed the same arguments that\nwere passed to the Constructor constructor \nfunction (<code>new Constructor( arguments ... )</code>).  If <code>setup</code> returns an\narray, those arguments are passed to [can.Construct::init] instead\nof the original arguments.</p>\n\n<p>Typically, you should only provide [can.Construct::init] methods to \nhandle initilization code. Use <code>setup</code> for:</p>\n\n<ul>\n<li>initialization code that you want to run before inheriting constructor's \ninit method is called.</li>\n<li>initialization code that should run without inheriting constructors having to \ncall base methods (ex: <code>MyBase.prototype.init.call(this, arg1)</code>).</li>\n<li>passing modified/normalized arguments to <code>init</code>.</li>\n</ul>\n\n<h2>Examples</h2>\n\n<p>The following is similar to code in [can.Control]'s setup method that\nconverts the first argument to a jQuery collection and extends the \nsecond argument with the constructor's [can.Construct.defaults defaults]:</p>\n\n<pre><code>can.Construct(\"can.Control\",{\n  setup: function( htmlElement, rawOptions ) {\n    // set this.element\n    this.element = $(htmlElement);\n\n    // set this.options\n    this.options = can.extend( {}, \n                               this.constructor.defaults, \n                               rawOptions );\n\n    // pass the wrapped element and extended options\n    return [this.element, this.options] \n  }\n})\n</code></pre>\n\n<h2>Base Functionality</h2>\n\n<p>Setup is not defined on can.Construct itself, so calling super in inherting classes\nwill break.  Don't do the following:</p>\n\n<pre><code>Thing = can.Construct({\n  setup : function(){\n    this._super(); // breaks!\n  }\n})\n</code></pre>", "ret": {"description": "<p>If an array is return, [can.Construct.prototype.init] is \ncalled with those arguments; otherwise, the original arguments are used.</p>", "type": "Array|undefined"}, "src": {"query": "", "fragment": "", "path": "can/construct/construct.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 304, "children": []})