c({"name": "makePackages", "params": {"options": {"description": "", "type": "", "optional": false, "order": 0, "name": "options"}, "appFiles": {"order": 1, "description": "", "name": "appFiles", "type": "appFiles", "optional": false}, "files": {"order": 2, "description": "", "name": "files", "type": "files", "optional": false}}, "ret": {"type": "undefined", "description": ""}, "type": "function", "comment": "<p>Creates packages that can be downloaded.</p>\n\n<p>Recursively uses getMostShared to pull out\nthe largest <strong>sharing</strong>.  It \nmakes a package of the sharing and marks\nthe apps that need that sharing.</p>\n\n<p>The apps that need the sharing</p>\n\n<p>packages are mostly dummy things.  </p>\n\n<p>a production file might steal multiple packages.</p>\n\n<p>say package A and package B</p>\n\n<p>say package A has jQuery</p>\n\n<p>so, the production file has code like:</p>\n\n<p>steal('jquery')</p>\n\n<p>It needs to know to not load jQuery</p>\n\n<p>this is where 'has' comes into place</p>\n\n<p>steal({id: 'packageA', has: 'jquery'})</p>\n\n<p>This wires up steal to wait until package A is finished for jQuery.</p>\n\n<p>So, we need to know all the packages and app needs, and all the things in that package.</p>", "src": {"query": "", "fragment": "", "path": "steal/build/apps/apps.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 354, "children": []})