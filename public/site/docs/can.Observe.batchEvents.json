c({"name": "can.Observe.batchEvents", "children": ["can.Observe.static.startBatch", "can.Observe.static.stopBatch", "can.Observe.static.triggerBatch"], "type": "page", "comment": "<p><code>can.Observe.startBatch( batchStopHandler )</code> and\n<code>can.Observe.stopBatch( force, callStart )</code>\nare used specify atomic operations. <code>startBatch</code>\nprevents change events from being fired until <code>stopBatch</code> is called.</p>\n\n<p>The following listens to changes on a <code>player</code>:</p>\n\n<pre><code>var player = new can.Observe({\n  tvshow: \"The Simpsons\"\n});\n\nplayer.bind(\"change\",function(ev, attr, how, newVal, oldVal){\n  console.log(\"changed\", attr );\n});\n</code></pre>\n\n<p>The \"change\" callback handler does not get called until\nafter <code>tvshow</code> is removed, <code>song</code> is added, and <code>stopBatch</code> \nis called.</p>\n\n<pre><code>can.Observe.startBatch();\n\nplayer.removeAttr(\"tvshow\");\nplayer.attr(\"song\",\"What makes you beautiful\");\n\ncan.Observe.stopBatch();\n</code></pre>\n\n<p>Performance and correctness are the two most common reasons\nto use batch operations.</p>\n\n<h2>Correctness</h2>\n\n<p>Sometimes, an object can be temporarily in an invalid \nstate. For example, the previous <code>player</code> should have \na <code>tvshow</code> or <code>song</code> property, but not both. Event listeners should \nnever be called in an intermediate state.  We can make this happen \nwith <code>startBatch</code>, <code>stopBatch</code> and\nthe <code>can/observe/setter</code> plugin as follows:</p>\n\n<pre><code>// Selection constructor function inherits from Observe\nPlayer = can.Observe({\n\n  // called when setting tvshow\n  setTvshow: function(newVal, success){\n    can.Observe.startBatch();\n    this.removeAttr(\"song\")\n    success(newVal);\n    can.Observe.stopBatch();\n  },\n  // called when setting song\n  setSong: function(newVal, success){\n    can.Observe.startBatch();\n    this.removeAttr(\"tvshow\")\n    success(newVal);\n    can.Observe.stopBatch();\n  }\n});\n\n// a new selection instance\nvar player =   new Player({song: \"Amish Paradise\"});\n\nplayer.bind(\"change\", function( ev, attr, how, newVal, oldVal ){\n  console.log(\"changed\", attr, how, s.attr() );\n});\n\nconsole.log(\"start\")\ns.attr(\"tvshow\",\"Breaking Bad\");\nconsole.log(\"end\")\n</code></pre>\n\n<p>Use <code>statBatch</code> and <code>stopBatch</code> to make sure events \nare triggered when an observe is in a valid state. </p>\n\n<h2>Performance</h2>\n\n<p>CanJS synchronously sends events when a property changes.\nThis makes certain patterns easier. For example, if you \nare doing live-binding, and change a property, the DOM is \nimmediately updated.</p>\n\n<p>Occasionally, you may find yourself changing many properties at once. To \nprevent live-binding from performing unnecessary updates, \nwrite the property updates within a <code>startBatch</code>/<code>stopBatch</code>.</p>\n\n<p>Consider a list of items like:</p>\n\n<pre><code>var items = new Items([\n  {selected: false},\n  {selected: true},\n  {selected: false}\n])\n</code></pre>\n\n<p>And a template that renders the number of selected items:</p>\n\n<pre><code>var template = can.view.mustache(\"{{count}}\")\n\n$(\"#itemCount\").html(template({\n  count: function(){\n      var count = 0;\n      items.each(function(item){\n        count += item.attr('selected') ? 1 : 0\n      })\n      return count\n   }\n}))\n</code></pre>\n\n<p>The following updates the DOM once per click:</p>\n\n<pre><code>$(\"#selectAll\").click(function(){\n    can.Observe.startBatch()\n    items.each(function(item){\n      item.attr('selected', true)\n    })\n    can.Observe.stopBatch()\n})\n</code></pre>\n\n<h2>batchNum</h2>\n\n<p>All events created within a <code>startBatch</code> / <code>stopBatch</code> share the same batchNum value. To \nrespond only once for a given batchNum, you can do it like:</p>\n\n<pre><code>var batchNum;\nobs.bind(\"change\", function( ev, attr, how, newVal, oldVal ){\n if( !ev.batchNum || ev.batchNum !== batchNum ) {\n   batchNum = ev.batchNum;\n   // do your code here!\n }\n});\n</code></pre>\n\n<h2>Automatic Batching</h2>\n\n<p>Libraries like Angular and Ember always batch \noperations. Set this up with:</p>\n\n<pre><code>can.Observe.startBatch();\nsetTimeout(function(){\n  can.Observe.stopBatch(true, true);\n  setTimeout(arguments.callee, 10)\n},10);\n</code></pre>\n\n<p>This batches everything that happens within the same thread of execution\nand/or within 10 ms of ech other. </p>", "parents": ["can.Observe"], "src": "can/observe/batch_events.md"})