c({"name": "can.Observe.static.stopBatch", "params": {"force": {"description": "", "type": "", "optional": false, "order": 0, "name": "force"}, "callStart": {"description": "", "type": "", "optional": false, "order": 1, "name": "callStart"}}, "ret": {"type": "undefined", "description": ""}, "type": "function", "parents": ["can.Observe.batchEvents", "can.Observe.static"], "comment": "<p><code>can.Observe.stopBatch([force,] [callStart])</code> decrements the \ninternal counter and potentially triggers all pending change events. Example:</p>\n\n<pre><code>var person = new can.Observe({\n     first: \"Alexis\",\n  last:  \"Abril\"\n});\n\nperson.bind(\"first\", function(){\n     console.log(\"first changed\")\n}).bind(\"change\", function(){\n     console.log(\"change\")\n});\n\ncan.Observe.startBatch();\nperson.attr(\"first\",\"Alex\");\n\nsetTimeout(function(){\n     can.Observe.stopBatch();\n},100);\n</code></pre>\n\n<p><code>can.Observe.startBatch(true)</code> dispatches all\npending requests no matter what the internal transaction\ncounter is set to. Example:</p>\n\n<pre><code>can.Observe.startBatch();\ncan.Observe.startBatch();\nperson.attr('first',\"Julie\");\ncan.Observe.stopBatch(true);\n</code></pre>\n\n<p><code>can.Observe.startBatch(true, true)</code> dispatches\nall pending requests and immediately calls\n<code>can.Observe.startBatch</code>.</p>", "src": {"query": "", "fragment": "", "path": "can/observe/observe.js", "dir": {"prototype": {}}, "filename": {"prototype": {}}, "ext": {"prototype": {}}, "domain": {"prototype": {}}, "isCrossDomain": {"prototype": {}}, "isRelativeToDomain": {"prototype": {}}, "hash": {"prototype": {}}, "search": {"prototype": {}}, "add": {"prototype": {}}, "join": {"prototype": {}}, "normalize": {"prototype": {}}, "isRelative": {"prototype": {}}, "pathTo": {"prototype": {}}, "mapJoin": {"prototype": {}}, "addJS": {"prototype": {}}, "toString": {"prototype": {}}, "insertMapping": {"prototype": {}}}, "line": 189, "children": []})