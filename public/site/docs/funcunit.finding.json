c({"name": "funcunit.finding", "type": "page", "comment": "<h2>The S Method</h2>\n\n<p>S is a copy of the $ method.  It is used to find elements in the page you're testing.  It works \nslightly differently than $.</p>\n\n<pre><code class='javascript'>S( selector, [context] )</code></pre>\n\n<h3>Params</h3>\n\n<p><strong>selector</strong> <code>{String|Function|Object}</code></p>\n\n<p><em>String</em></p>\n\n<p>The S method accepts any valid jQuery selector string, just like $.  One difference from $ is that this \nquery will happen in the context of the window of the page you're testing, not the QUnit page where it runs.</p>\n\n<p>Depending on the context in which S is called, this selector may be used immediately and return a jQuery \ncollection, or it may cache the selector, which will be used in the asynchronous queue later to find elements \nwhen previous queued methods have finished.  Read more about this below.</p>\n\n<pre><code class='javascript'>// look up .foo elements in the application window\nS(\".foo\")</code></pre>\n\n<p><em>Function</em></p>\n\n<p>If a function is provided, it will be added to the queue to be run after previous queued methods.</p>\n\n<pre><code class='javascript'>// Wait for this to be visible\nS(\".grid\").visible()\n\n// Run after the previous wait completes\nS(function(){\n    ok(S(\".foo\").hasClass('bar'))\n})</code></pre>\n\n<p><em>Object</em></p>\n\n<p>If you want to reference the test page's window or document, pass <code>S.window</code> \nor <code>S.window.document</code>.</p>\n\n<pre><code class='javascript'>// click the test page's document element\nS(S.window.document).click()</code></pre>\n\n<p><strong>[context]</strong> <code>{Number|String}</code></p>\n\n<p>Context is an optional parameter.  If provided, the number or string is used as the \nframe number or name in the document.frames array of the tested page.  The frame is looked up, \nand this is passed as the context of the query.</p>\n\n<pre><code class='javascript'>// find something in the 0th frame\nS(\"a.mylink\", 0)\n\n// find something within the frame that has name=\"myframe\"\nS(\"a.another, \"myframe\")</code></pre>\n\n<h3>Synchronous vs asynchronous queries</h3>\n\n<p>As mentioned above, S sometimes performs synchronous queries and returns a jQuery collection object. <br />\nOther times, it returns nothing, caches the selector, and adds a method to [FuncUnit._queue].</p>\n\n<p><strong>Synchronous</strong></p>\n\n<p>All [funcunit.actions actions] and [funcunit.waits waits] are asynchronous commands.  They add themselves to \n[FuncUnit.queue] and run in order.  Each action and wait accepts an optional callback parameter.  This callback \nruns after the queued method completes.</p>\n\n<p>Inside these callbacks, you get information about the page and perform assertions, synchronously. \nAny time S is called inside a callback, it runs synchronously and returns a jQuery collection.</p>\n\n<pre><code class='javascript'>S(\".foo\").visible(function(){\n  // this will run immediately and return a $ collection\n  var size = S(\".bar\").size();\n  equal(size, 5);\n})</code></pre>\n\n<p>Inside these callbacks, you can set breakpoints and debug tests.</p>\n\n<p>Sometimes, you want to get information about the page as soon as a test begins.  Later in a callback, \nyou can compare this initial value with the current value.</p>\n\n<p>If you call S at the start of a test, it will also run immediately and return a $ collection. Until the first \nitem is added to the queue, S will run synchronously.</p>\n\n<pre><code class='javascript'>test(\"contacts test\", function(){\n  // runs synchronously\n  var origNbrItems = S(\".contacts\").size();\n  S(\".addNew\").click(function(){\n    var newNbrItems = S(\".contacts\").size();\n    ok(newNbrItems > origNbrItems);\n  });\n})</code></pre>\n\n<p>Beware that you MUST put any synchronous getters inside a callback or at before any actions or waits.</p>\n\n<pre><code class='javascript'>test(\"contacts test\", function(){\n  S(\".addNew\").click(function(){\n    var newNbrItems = S(\".contacts\").size();\n    ok(newNbrItems > origNbrItems);\n  });\n  // this will fail!  \n  var origNbrItems = S(\".contacts\").size();\n})</code></pre>\n\n<p><strong>Asynchronous</strong></p>\n\n<p>Except for the cases outlined above, the S method needs to run asynchronously in the correct queue order. In this case, doing an \nimmediate query and returning a collection would be wasteful and slow down test performance.</p>\n\n<pre><code class='javascript'>// 1. query for .container\n// 2. add a method to the queue that repeatedly checks when .container is visible\nS(\".container\").visible();\n\n// 3. when the previous method completes, do a query for .foo\n// 4. click .foo\nS(\".foo\").click()</code></pre>\n\n<h3>Why S?</h3>\n\n<p>S is a \"copy\" of $, created using [http://api.jquery.com/jQuery.sub/ jQuery.sub].  All FuncUnit methods, \nlike actions, waits, and traversers, are added to S.fn.  All the jQuery methods that FuncUnit doesn't \noverload are callable on S collections. </p>\n\n<p>The reason for this is to preserve jQuery in the test page, unmodified.  If you want to use jQuery, none of \nits methods are modified. jQuery can be used to do unit testing, or to directly access the test page and do \ncustom things.</p>\n\n<pre><code class='javascript'>// accessing elements within the test page\nok($(\".foo\").hasClass(\"bar\"))</code></pre>\n\n<h3>Extending S</h3>\n\n<p>Occassionally there will be tests that need some jQuery plugins to run correctly.  To extend S </p>\n\n<ol>\n<li>Load your jQuery plugin</li>\n<li>Add the plugin method to S.fn</li>\n</ol>\n\n<pre><code class='javascript'>steal(\"funcunit\", \"resources/myplugin.js\", function(){\n  S.fn.myplugin = $.fn.myplugin;\n  // test code goes here\n})</code></pre>\n\n<p>Most likely this method works synchronously so you have to use it inside a callback, where S is \nreturning synchronously.</p>\n\n<pre><code class='javascript'>// inside a wait callback, S returns a jQuery collection\nS(\".foo\").visible(function(){\n  // call myplugin on jQuery collection\n  var els = S(\".contact\").myplugin()\n})</code></pre>\n\n<h2>Traversing</h2>\n\n<p>FuncUnit provides its own asynchronous versions of jQuery traverser methods \n[FuncUnit.prototype.find find], [FuncUnit.prototype.closest closest], \n[FuncUnit.prototype.next next], [FuncUnit.prototype.prev prev], \n[FuncUnit.prototype.siblings siblings], [FuncUnit.prototype.last last], \nand [FuncUnit.prototype.first first].  The FuncUnit versions add themselves to \n[FuncUnit._queue].  When they are called, they take the current jQuery collection object, \nmodify it with their traversal, and pass the result to the next method in the queue.</p>\n\n<pre><code class='javascript'>// click .container, wait for width to be 500px\nS(\".container\").click().width(500)\n  // find .contact inside container, click it\n  .find(\".contact\").click()</code></pre>", "title": "Finding Elements", "parents": ["FuncUnit"], "order": 1, "src": "funcunit/pages/finding.md", "children": []})