c({"name": "services", "type": "page", "comment": "<p>JavaScriptMVC's flexibility allows it to \nbe used with almost any service layer.  However, \nthis guide details suggests a service layer design \nthat minimizes the amount of extra work to get JavaScriptMVC running.</p>\n\n<p>In general, the service layer should be as \nthin as possible and reflect the Database \nqueries and results the server must make \nto get the data.  This keeps things flexible \nfrom the client's perspective.</p>\n\n<h2>JSON Rest Part 1</h2>\n\n<p>The best over-all service layer can be described as JSON REST.  </p>\n\n<p>JSON is used as the data received and sometimes sent to the server.</p>\n\n<p>REST is [http://en.wikipedia.org/wiki/Representational<em>state</em>transfer Representational State Transfer]\nwhere there are resource urls that are \nmodified with <code>GET POST PUT</code> and <code>DELETE</code> methods.  </p>\n\n<p>A brief example is a service API for messages.  The server might expose the \nfollowing METHOD and URLS:</p>\n\n<p><code>GET /messages        </code> - gets an array of messages from the server.\n<code>GET /messages/{id}   </code> - gets a single message from the server.\n<code>POST /messages       </code> - creates a message from the server.\n<code>PUT /messages/{id}   </code> - updates a message from the server.\n<code>DELETE /messages/{id}</code> - destroys a message from the server.</p>\n\n<h2>Query String Params</h2>\n\n<p>Before going into detail about what each \n<code>METHOD URL</code> does, it's worth \nquickly describing how parameters are \npassed to the query string.  [can.Model] passes \nparameters to your framework of choices ajax handler\nand that gets converted by [can.param]. \nFor example, if we wanted\nall messages for a given user, \nsorted first by date, then by the users's name, \nwe might call something like:</p>\n\n<pre><code>$.get('/messages',{\n  userId: 5, \n  order: ['createdAt ASC','user.name ASC'] \n})\n</code></pre>\n\n<p>Which produces:</p>\n\n<pre><code class='text'>GET /messages?\n        userId=5&\n        order%5B%5D=createdAt+ASC&\n        order%5B%5D=user.name+ASC</code></pre>\n\n<p>Lets walk through each REST service example.</p>\n\n<h2>GET /messages</h2>\n\n<p>A request to GET /messages should return \nall message records visible to the \nrequesting user.  The data should look like:</p>\n\n<pre><code>{\n  \"data\": [\n      {\n         \"id\" : 1,\n         \"fromUserId\": 921,\n         \"text\": \"Hello World\",\n         \"createdAt\" : 1024324214123\n      },\n      {\n         \"id\" : 2,\n         \"fromUserId\": 923,\n         \"text\": \"Goodnight World\",\n         \"createdAt\" : 23524365346543\n      },\n      ...\n  ],\n  \"count\": 100 \n}\n</code></pre>\n\n<p>Where:</p>\n\n<ul>\n<li><code>data</code> - has an array of objects (in this case 100), \neach object contains the data for a single message.</li>\n<li><code>count</code> - lists the number of items that \nwould be returned if a limit was not used.  In this \ncase, no limit was used so count matches the number of items.</li>\n</ul>\n\n<p><code>GET /messages</code> will typically take \narguments passed in as name=value parameters \nin the query string like:</p>\n\n<blockquote>\n  <p><code>GET /messages?limit=10&amp;offset=20&amp;order[]=createdAt+DESC</code></p>\n</blockquote>\n\n<p>Common name / values are:</p>\n\n<ul>\n<li><code>limit</code> - the total number of items to return</li>\n<li><code>offset</code> - the position in the 'total' set to start returning items</li>\n<li><code>order</code> - an array of 'NAME SORTORDER' pairs</li>\n</ul>\n\n<p>You'll notice that these properties can effectively be sent straight away to a DB query.</p>\n\n<h4>Relationships</h4>\n\n<p>Often, you want to get all data for a particular item.  For example, \nall messages from user 52.  Instead of requesting something like:</p>\n\n<blockquote>\n  <p><code>GET /users/52/messages</code></p>\n</blockquote>\n\n<p>A request should be made to:</p>\n\n<blockquote>\n  <p><code>GET /messages?fromUserId=52</code></p>\n</blockquote>\n\n<p>The service should limit messages to only those where <code>fromUserId = 52</code>.</p>\n\n<h3>Related Data</h3>\n\n<p>Another common problem is when, for \nperformance reasons, you want the 'joined' \ndata for a particular field.  For example, \nwhen getting messages, you might want to also \nwant to get the user data from fromUserId.  </p>\n\n<p>In this case, we encourage the use \nof an 'include' option which \nsignifies including additional data like:</p>\n\n<blockquote>\n  <p><code>GET /messages?include[]=fromUser</code></p>\n</blockquote>\n\n<p>The fromUser data will be added to each message object like:</p>\n\n<pre><code>{\n  \"data\": [\n      {\n         \"id\" : 1,\n         \"fromUserId\": 921,\n         \"text\": \"Hello World\",\n         \"createdAt\" : 1024324214123,\n         \"fromUser\": {\n           \"id\" : 921,\n           \"name\" : \"Justin Meyer\"\n         }\n      },\n      ...\n  ],\n  \"count\": 100 \n}\n</code></pre>\n\n<h2>GET /messages/{id}</h2>\n\n<p>Gets a single item from the server.  It should return just the JSON data for the object like:</p>\n\n<pre><code>-&gt;{\n    \"id\" : 1,\n    \"fromUserId\": 921,\n    \"text\": \"Hello World\",\n    \"createdAt\" : 1024324214123\n}\n</code></pre>\n\n<h2>POST /messages</h2>\n\n<p>Creates a message on the server.  Typically, \nthe body of this request is JSON data that \nlooks exactly like the data from a GET request, \nbut without the id property or any properties \nthe server might add.  For example, I can \ncreate a message by sending:</p>\n\n<pre><code>POST /messages\n{\n    \"fromUserId\": 921,\n    \"text\": \"A new message\"\n}\n</code></pre>\n\n<p>The server is going to add the id and createdAt property and should return those as JSON in the response:</p>\n\n<pre><code>-&gt;{\n    \"id\": 22,\n    \"createdAt\": 1224324214123\n}\n</code></pre>\n\n<h2>PUT /messages/{id}</h2>\n\n<p>This updates a resource.  Similar to POST, \nthe body should be JSON that matches what \nthe data from a GET request looks \nlike.  However, only fields that are changing \nare necessary to send.  For example, we we \nwant to update the text of a message:</p>\n\n<pre><code>PUT /messages/22\n{\n  'text': \"An updated EVIL message\"\n}  \n</code></pre>\n\n<p>The response should have any fields that were \nmodified or adjusted on the server.  For \nexample, the server might filter the word \n\"EVIL\" out of messages and be updating some \n'updatedAt' property.  It should return:</p>\n\n<pre><code>-&gt;{\n  'text' : \"An updated message\",\n  'updatedAt' : 123254356346241\n}\n</code></pre>\n\n<p>If no filtering or modifying of other changes \nhappened, the server can just return \nan empty object: <code>{}</code>.</p>\n\n<h2>DELETE /messages/{id}</h2>\n\n<p>Destroys a resource from the server.  </p>\n\n<h2>Sending Dates</h2>\n\n<p>The best way of sending dates is an integer representing the Julian date like:</p>\n\n<pre><code>createdAt: 12313123133423\n</code></pre>\n\n<p>Where we can convert that easily to a JavaScript date like</p>\n\n<pre><code>new Date(123123133423)\n</code></pre>\n\n<h2>CUD Multiple Items with a Single Request</h2>\n\n<p>Often, you want to create, update, or delete items with a single request.  This is\nmost often done with [can.Model.List].</p>\n\n<h2>Handling Errors</h2>\n\n<p>When an error happens, make sure your server sends back the \nproper HTTP status code.  The response body should be a JSON object with\nproperty names mapped to an array of errors:</p>\n\n<pre><code>{\n   email : [\"Formatting is incorrect\",\"No email is provided\"]\n}\n</code></pre>", "title": "Ajax Service Guidelines", "parents": ["tutorials"], "order": 9, "src": "tutorials/services.md", "children": []})